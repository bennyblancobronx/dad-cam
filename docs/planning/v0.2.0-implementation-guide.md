# Dad Cam v0.2.0 -- Implementation Guide

For developers new to this codebase.

Source of truth: `docs/planning/v0.2.0-master-plan.updated.md`
Prerequisite reading: `about.md`, `contracts.md`, `techguide.md`
Audit date: 2026-01-29
Guide version: 4 (post-implementation sync -- all 11 steps complete at v0.1.103)

---

## Before You Touch Anything

Read these three files in this order. Do not skip them.

1. **`about.md`** -- What the product IS. Dad Cam is a cross-platform video library for old digital camera footage. Not an editor. Not a workflow tool. A memory machine. One-line: "Photos app for video memories + automatic home movie generator."

2. **`contracts.md`** -- 18 non-negotiable rules. The ones you will hit most often:
   - Contract 12: Originals are NEVER deleted or modified by the app. Absolute.
   - Contract 13: App works 100% offline. No account. No telemetry. No external API calls.
   - Contract 15: Same core features on macOS, Windows, Linux.
   - Contract 16: Crash-safe, resumable jobs. USB disconnect mid-ingest does not corrupt library.
   - Contract 17: SQLite is the source of truth. Inspectable. Portable.
   - Contract 18: ffmpeg, ffprobe, exiftool are bundled with the app (not system-installed).
   - Master plan non-negotiable 6: "Export originals" is always a file copy, never a transform.

3. **`techguide.md`** -- The technical manual. Core loop, CLI commands, architecture details.

---

## Getting Started (Build and Run)

### Prerequisites

- **Node.js** 20+ and npm 9+
- **Rust** (stable, 2021 edition) via rustup
- **Tauri CLI**: `npm install` installs it as a dev dependency

### First Run

```bash
# Clone and install JS dependencies
cd dad-cam
npm install

# Run in development mode (starts both Vite dev server and Tauri/Rust backend)
npm run tauri dev

# Build for production
npm run tauri build
```

`npm run tauri dev` compiles Rust on first run (slow), then hot-reloads the React frontend on subsequent saves. Rust changes require a recompile (automatic, but slower than JS hot reload).

### How the App Works (Architecture for Newcomers)

Dad Cam uses **Tauri 2.0**, which bundles a Rust backend with a web-based frontend. Think of it like Electron, but with Rust instead of Node.js.

```
+--------------------------+
|  React Frontend (UI)     |  <-- src/ directory (TypeScript, JSX)
|  Runs in a webview       |
+--------------------------+
        | invoke("command_name", args)
        v
+--------------------------+
|  Rust Backend (Logic)    |  <-- src-tauri/src/ directory
|  Runs natively           |
+--------------------------+
        |
  +-----+------+
  |            |
SQLite      FFmpeg
(.dadcam/    (video
dadcam.db)   processing)
```

Key concepts:
- **Tauri commands**: Rust functions annotated with `#[tauri::command]` that the frontend calls via `invoke()`. This is IPC (inter-process communication). The frontend never touches the filesystem or database directly.
- **Tauri Store plugin**: Persistent JSON key-value storage for app-level settings (stored in OS app data directory). This is separate from the SQLite database.
- **Tauri events**: One-way messages from Rust to the frontend. Used for progress updates during long operations. Frontend listens with `listen()`.
- **DbState**: A `Mutex<Option<Connection>>` managed by Tauri. When a library is open, the connection is `Some(conn)`. When closed, it's `None`. Commands acquire the lock to use the database.

### Project Structure (Quick Map)

```
dad-cam/
  about.md          Product definition (read first)
  contracts.md      18 non-negotiable rules (read second)
  techguide.md      Technical manual
  changelog.md      Version history (source of truth for version number)
  package.json      React 19.1.0, TypeScript 5.8.3, Vite 7.0.4
  src/              React frontend
  src-tauri/        Rust backend
```

---

## What You Are Building

v0.2.0 adds licensing, VHS export, a proper import dialog, camera registration, and a dev menu to an existing Tauri 2.0 desktop app. The app already handles import, browsing, scoring, events, and preview generation. Your job is to add the missing pieces without breaking what exists.

### v0.2.0 Deliverables (8 items)

Reference: Master plan section "v0.2.0 Product Scope > Primary Deliverables"

1. Settings v2 + first-run wizard (Simple vs Advanced)
2. Licensing system (trial, purchased, rental, dev)
3. VHS Export (timeline builder + FFmpeg pipeline)
4. Import dialog (event assignment + progress + summary)
5. Camera system (bundled DB + custom "Dad Cams" + matching)
6. LeftNav improvements (Favorites link, optional Cameras tab)
7. Feature toggles (Advanced only)
8. Dev menu (formulas + camera DB editing + license tools + debug)

### NOT in v0.2.0 (do not build these)

Reference: Master plan section "Not in v0.2.0"

- FireWire / tape capture
- Cloud sync / subscriptions
- Multi-view camera sync
- Editing tools beyond the VHS pipeline + basic clip export

### Hardware in scope

Reference: Master plan section "Development Focus"

- USB digital cameras as storage devices (Mass Storage / MTP best-effort)
- Memory cards via card readers
- File-based ingest from folders

### Hardware out of scope

- FireWire
- VHS/MiniDV tape capture
- Multi-camera sync / multi-view

---

## Terminology

Reference: Master plan section "Core Data Model > Projects"

The user-facing term is **Project**. Internally, files and tables still say "library" (the DB table is `libraries`, the folder is `.dadcam/`). Do not rename internal code to "project" -- just use "Project" in all user-facing UI text.

- Simple mode: one project only ("Default Project")
- Advanced mode: multiple projects + recent projects list

---

## Tech Stack (What Already Exists)

```
Frontend: React 19 + TypeScript 5.8 + Vite 7
Backend:  Rust (2021 edition) via Tauri 2.0
Database: SQLite via rusqlite 0.31 (bundled -- no system SQLite needed)
Hashing:  BLAKE3 via blake3 1.5 crate
Video:    FFmpeg/ffprobe via ffmpeg-sidecar 2.0 crate
Settings: Tauri Store plugin (JSON file in OS app data dir)
```

Verified against `package.json` and `src-tauri/Cargo.toml` on 2026-01-28.

Architecture:

```
React Component --> API wrapper (src/api/*.ts) --> invoke()
                                                      |
                                              Tauri Command (Rust)
                                                      |
                                              rusqlite --> SQLite
                                              ffmpeg-sidecar --> FFmpeg
```

All heavy work happens in Rust. The frontend calls Rust via Tauri commands (IPC). The frontend never touches the filesystem or database directly.

---

## Project Layout (Exact, Verified Against Source 2026-01-28)

```
dad-cam/
  about.md                        # Product definition (read first)
  contracts.md                    # 18 non-negotiable rules (read second)
  techguide.md                    # Technical manual
  changelog.md                    # Version history (source of truth for version number)
  src/                            # React frontend
    App.tsx                       # Root component, routing, settings state
    App.css                       # Single CSS file (Braun Design Language tokens)
    main.tsx                      # React entry point
    constants.ts                  # APP_VERSION string
    components/                   # React components (28 total)
      LibraryView.tsx             # Main workspace (clips, events, dates, settings sub-views)
      LibraryDashboard.tsx        # Pro mode: multi-library grid
      WelcomeDashboard.tsx        # Personal mode: landing page
      SettingsView.tsx            # Full-page settings (left nav + content)
      SettingsPanel.tsx           # Settings panel (inline variant)
      MainLayout.tsx              # Header + LeftNav + content
      LeftNav.tsx                 # Sidebar navigation container
      ClipGrid.tsx                # Virtualized clip grid (TanStack Virtual)
      VideoPlayer.tsx             # Modal player with keyboard shortcuts
      FilterBar.tsx               # Filters, search, sort, date range
      EventView.tsx               # Event detail with clip list
      DateView.tsx                # Date detail with clips
      ClipThumbnail.tsx           # Grid cell with hover, selection
      SpriteHover.tsx             # Sprite sheet hover scrubbing
      ErrorBoundary.tsx           # Crash protection wrapper
      LibraryCard.tsx             # Library card for dashboard
      ScoreBadge.tsx              # Score display
      ScoreBreakdown.tsx          # Component score visualization
      ScoreOverrideButtons.tsx    # Promote/demote/pin controls
      ScoringStatus.tsx           # Scoring progress
      BestClipsPanel.tsx          # Top clips display
      nav/                        # Left nav sections (4 files)
        LibrarySection.tsx
        EventsSection.tsx
        DatesSection.tsx
        SettingsSection.tsx
      modals/                     # Modal dialogs (3 files)
        CreateEventModal.tsx
        EditEventModal.tsx
        AddToEventModal.tsx
    api/                          # Tauri command wrappers (5 files)
      clips.ts
      events.ts
      scoring.ts
      settings.ts
      stills.ts
    types/                        # TypeScript interfaces (4 files)
      clips.ts                    # ClipView, ClipFilter, etc.
      events.ts                   # EventView, EventClipView, DateGroup
      scoring.ts                  # ClipScore, ScoringStatus, etc.
      settings.ts                 # AppSettings, AppMode, RecentLibrary
    utils/                        # Utility files (2 files)
      paths.ts
      thumbnailCache.ts           # LRU cache (500 entries)
  src-tauri/                      # Rust backend
    Cargo.toml                    # Rust dependencies
    tauri.conf.json               # Tauri config
    capabilities/default.json     # Permissions
    src/
      main.rs                     # Tauri app entry point (calls lib::run)
      lib.rs                      # Plugin setup, command registration, IngestResponse, start_ingest, get_jobs
      cli.rs                      # CLI binary entry point
      constants.rs                # All constants (paths, thresholds, weights, reason tokens)
      error.rs                    # DadCamError enum (12 error variants)
      tools.rs                    # ffmpeg/ffprobe/exiftool path resolution
      db/
        mod.rs                    # Database connection + init (open_db, init_library_folders)
        schema.rs                 # SQL queries + Rust structs (~1,179 lines)
        migrations.rs             # 3 migrations (core, scoring, events)
      hash/
        mod.rs                    # BLAKE3 fast hash + full hash + verify
      metadata/
        mod.rs                    # MediaMetadata struct, extract_metadata(), detect_media_type()
        ffprobe.rs                # Video metadata extraction
        exiftool.rs               # EXIF data extraction
      ingest/
        mod.rs                    # Ingest orchestration (create_ingest_job, run_ingest_job)
        discover.rs               # File discovery (discover_media_files)
        copy.rs                   # File copy with hash verification
      jobs/
        mod.rs                    # Job types + DB functions
        runner.rs                 # Job execution engine
      camera/
        mod.rs                    # Camera profile matching (CameraProfile, MatchRules, match_camera_profile)
      preview/
        mod.rs                    # DerivedParams, preview pipeline coordination
        proxy.rs                  # H.264 720p proxy generation
        thumb.rs                  # Poster frame JPG generation
        sprite.rs                 # Hover scrub sprite sheets + VTT
      scoring/
        mod.rs                    # ScoringResult, compute_overall, weighted scores
        analyzer.rs               # FFmpeg analysis runner
        scene.rs                  # scdet filter scoring
        audio.rs                  # ebur128 filter scoring
        sharpness.rs              # blurdetect filter scoring
        motion.rs                 # tblend + blackframe scoring
        tests.rs                  # Unit tests with lavfi fixtures
      commands/                   # Tauri command handlers (7 files)
        mod.rs                    # Module registration, DbState definition
        library.rs                # open_library, close_library, create_library, get_library_root
        clips.rs                  # get_clips, get_clip, get_clips_filtered, get_clip_view
        tags.rs                   # toggle_tag, set_tag
        scoring.rs                # get_clip_score, score_clip, get_scoring_status, get_best_clips, set_score_override, clear_score_override, queue_scoring_jobs
        settings.rs               # get_app_settings, save_app_settings, get_mode, set_mode, add_recent_library, remove_recent_library, get_recent_libraries, validate_library_path
        stills.rs                 # export_still
        events.rs                 # create_event, get_events, get_event, update_event, delete_event, add_clips_to_event, remove_clips_from_event, get_event_clips, get_clips_grouped_by_date, get_clips_by_date
```

### Current Tauri Commands (38 registered in lib.rs)

Counted directly from `src-tauri/src/lib.rs` lines 86-131, inside the `generate_handler![]` macro:

| Module | Count | Commands |
|--------|------:|---------|
| library | 4 | open_library, close_library, create_library, get_library_root |
| clips | 4 | get_clips, get_clip, get_clips_filtered, get_clip_view |
| tags | 2 | toggle_tag, set_tag |
| scoring | 7 | get_clip_score, score_clip, get_scoring_status, get_best_clips, set_score_override, clear_score_override, queue_scoring_jobs |
| settings | 8 | get_app_settings, save_app_settings, get_mode, set_mode, add_recent_library, remove_recent_library, get_recent_libraries, validate_library_path |
| stills | 1 | export_still |
| events | 10 | create_event, get_events, get_event, update_event, delete_event, add_clips_to_event, remove_clips_from_event, get_event_clips, get_clips_grouped_by_date, get_clips_by_date |
| ingest (lib.rs) | 2 | start_ingest, get_jobs |
| **Total** | **38** | |

### Current Database Schema (3 migrations, 17 tables)

Source: `src-tauri/src/db/migrations.rs` (uses `PRAGMA user_version` for version tracking)

How migrations work: The `MIGRATIONS` array in `migrations.rs` contains SQL strings. On database open, `run_migrations()` checks `PRAGMA user_version` against the array length and applies any pending migrations in order. Each migration is wrapped in a single batch execution followed by a version bump. Migrations are forward-only -- never edit a shipped migration.

**Migration 1 (Core):** 13 tables, 15 indexes

| # | Table | Purpose |
|---|-------|---------|
| 1 | libraries | One row per library (root_path, name, ingest_mode) |
| 2 | assets | Files (originals, proxies, thumbs, sprites, exports, sidecars) |
| 3 | clips | Logical video items (title, duration, resolution, codec, recorded_at) |
| 4 | clip_assets | Many-to-many: clips <-> assets with role (primary, proxy, thumb, sprite, sidecar) |
| 5 | camera_profiles | Camera model definitions (match_rules, transform_rules JSON) |
| 6 | tags | System tags: favorite, bad, archived |
| 7 | clip_tags | Many-to-many: clips <-> tags |
| 8 | jobs | Durable work queue (ingest, proxy, thumb, sprite, export, hash_full, score, ml, batch_ingest, batch_export, relink_scan) |
| 9 | job_logs | Per-job log entries (info, warn, error) |
| 10 | volumes | Removable/network drive tracking for relink |
| 11 | fingerprints | Size+duration and hash fingerprints for relink matching |
| 12 | ingest_files | Per-file ingest state for crash recovery |
| 13 | asset_volumes | Many-to-many: assets <-> volumes |

**Migration 2 (Scoring):** 2 tables, 4 indexes

| # | Table | Purpose |
|---|-------|---------|
| 14 | clip_scores | Machine-generated scores (overall + 4 components, versioned) |
| 15 | clip_score_overrides | User promote/demote/pin preferences |

**Migration 3 (Events):** 2 tables, 5 indexes

| # | Table | Purpose |
|---|-------|---------|
| 16 | events | Event metadata (name, type=date_range/clip_selection, date range, color, icon) |
| 17 | event_clips | Many-to-many join: events <-> clips |

Key schema facts you need to know:
- `clips` table already has `camera_profile_id` (nullable FK to camera_profiles) -- see migrations.rs line 44
- `clips` table does NOT have `camera_device_id` yet (you will add this in Migration 5)
- `events` has two types: `date_range` (auto-include clips by date) and `clip_selection` (manual)
- `event_clips` is a many-to-many join table -- the master plan says to keep this model
- `jobs.type` CHECK constraint lists: ingest, proxy, thumb, sprite, export, hash_full, score, ml, batch_ingest, batch_export, relink_scan
- `assets.type` CHECK constraint lists: original, proxy, thumb, sprite, export, sidecar

### Current Settings (v1)

Source: `src-tauri/src/commands/settings.rs`

Settings are stored via the **Tauri Store plugin** -- a JSON key-value file at the OS app data directory (e.g., `~/Library/Application Support/com.dadcam.app/settings.json` on macOS). Settings are NOT in SQLite. The database lives per-library at `.dadcam/dadcam.db`; settings are global across all libraries.

The Tauri Store reads/writes individual keys, not the whole object at once. Look at how `get_app_settings` in `settings.rs` (lines 63-98) reads each key individually with fallbacks. This is important: if a key is missing (e.g., from a version mismatch), the function falls back to defaults rather than crashing.

Rust (from settings.rs lines 11-48):
```rust
const SETTINGS_VERSION: u32 = 1;

enum AppMode { Personal, Pro }   // serializes as "personal" / "pro"

struct AppSettings {
    version: u32,                        // 1
    mode: AppMode,                       // personal or pro
    last_library_path: Option<String>,
    recent_libraries: Vec<RecentLibrary>,
}

struct RecentLibrary {
    path: String,
    name: String,
    last_opened: String,
    clip_count: i64,
    thumbnail_path: Option<String>,
}
```

TypeScript (from src/types/settings.ts):
```typescript
type AppMode = 'personal' | 'pro';

interface AppSettings {
  version: number;       // 1
  mode: AppMode;
  lastLibraryPath: string | null;
  recentLibraries: RecentLibrary[];
}
```

### Current Rust Dependencies (Cargo.toml)

Source: `src-tauri/Cargo.toml`

```
tauri 2, tauri-plugin-opener 2, tauri-plugin-dialog 2, tauri-plugin-store 2
rusqlite 0.31 (bundled), blake3 1.5, ffmpeg-sidecar 2.0
clap 4.5 (derive), serde 1.0 (derive), serde_json 1.0
chrono 0.4 (serde), anyhow 1.0, thiserror 1.0
walkdir 2.5, directories 5.0, uuid 1.0 (v4)
regex 1.10, hostname 0.3, filetime 0.2
```

Missing for v0.2.0 (you will add):
- `keyring` -- OS keychain access for license key storage
- Possibly `hmac` + `sha2` -- for license key validation (implementation choice)

### Current App.tsx Routing Logic

Source: `src/App.tsx`

The app currently routes based on (in this order):
1. `isLoading` -- shows loading screen
2. `library` is set -- shows `LibraryView` (wrapped in ErrorBoundary)
3. `unmountedLibrary` -- shows unmounted error with retry/remove
4. `settings.mode === 'pro'` -- shows `LibraryDashboard` or `SettingsView`
5. Default -- shows Personal mode welcome screen with open/create forms

**v0.2.0 must add:**
- First-run wizard gate: when `firstRunCompleted === false`, show wizard before anything else
- Keyboard listener for Dev Menu hotkey (Cmd/Ctrl+Shift+D)
- Dark mode class application based on `settings.theme`
- Trial banner rendering when license is in trial state

---

## User Experience Modes (DECIDED)

Reference: Master plan section "User Experience Modes"

These enum values are final. Use exactly:
- `simple` (replaces `personal`)
- `advanced` (replaces `pro`)

### Simple mode (default for new users)

- Single Project only ("Default Project")
- Cameras tab hidden in LeftNav
- Feature toggles hidden in Settings
- Targets low-end PCs
- Generic camera profile fallback unless matched to DB / registered Dad Cam
- Theme: light only (no toggle visible)

### Advanced mode

- Multiple Projects supported
- Cameras tab available (and toggle-able)
- Feature toggles visible in Settings
- Theme toggle (light/dark)
- Can register specific cameras ("Dad Cams")
- Dev menu access (hotkey + easter egg)
- Score threshold selection available in VHS export

### Feature toggle defaults

Reference: Master plan section "Feature toggle defaults"

| Feature | Simple | Advanced |
|---------|-------:|--------:|
| Screen grabs | On | On |
| Face detection | Off | On |
| Best clips | On | On |
| Cameras tab | Hidden | On |

Simple mode hides the toggle UI entirely -- you cannot change these in Simple mode.

---

## Licensing & Trial (DECIDED)

Reference: Master plan sections "Licensing & Trial", "Soft lock behavior after trial expires"

### License tiers

| Tier | Cost | Duration | Features |
|------|------|----------|----------|
| Trial | Free | 14 days | Full functionality |
| Purchased | $99 one-time | Permanent | Full functionality |
| Rental | Free (key provided with rental) | Rental window | Full functionality |
| Dev | Internal | Permanent | Full + debug features (raw SQL) |

### Trial start (IMPORTANT -- from master plan "Migration" section)

Trial begins on first v0.2.0 launch unless a valid license already exists in the keychain. The trial start date is stored in the keychain (not in settings JSON) so it survives settings file deletion or corruption.

### Soft lock after trial expires (Option A -- DECIDED)

**CAN do (always):**
- Open app
- Open projects
- Browse / play footage
- View existing metadata, events, favorites, best-clips results (if already computed)
- Export originals (file copy) -- non-hostage rule (contract 12 / master plan non-negotiable 6)
- Export rendered outputs WITH watermark + 1280x720 max cap

**CANNOT do:**
- Import new footage
- Run new auto-edit jobs (scoring, face detection, refresh best clips)
- Register cameras (reading EXIF is OK; saving to custom DB is not)

### Rendered export restrictions (when unlicensed)

Reference: Master plan section "Export rendered outputs restrictions"

"Rendered export" = anything that produces a new video file via FFmpeg (VHS edit, compilation, transcoded clip).

Enforce BOTH:
- Watermark: "Dad Cam Trial" burned into video
- 720p cap: output downscaled to 1280x720 max

### Rental keys

For v0.2.0: rental keys are offline-valid, unlimited duration. Add expiry in v0.3.x if needed.

### Dev key

Gated behind `DCAM-D-` prefix. Enables raw SQL in dev menu.

---

## Core Data Model (v0.2.0 additions)

Reference: Master plan section "Core Data Model"

### Camera model (FIXED -- two concepts required)

**1) Camera Profile** (model-level info):
"Sony HDR-CX405", "Canon VIXIA", etc.
- make, model, parsing hints, optional LUT/processing hints, known quirks
- Stored in bundled JSON: `resources/cameras/canonical.json`
- Also stored in SQLite `camera_profiles` table (already exists in Migration 1)

**2) Camera Device** (a physical rental unit -- "Dad Cam"):
- stable UUID, linked to a profile
- USB fingerprint(s) (best-effort)
- serial number (if present)
- fleet label (e.g., "DadCam-12")
- rental notes
- Stored in user JSON: `~/.dadcam/custom_cameras.json`
- Also stored in new SQLite `camera_devices` table (you will create)

**Clip camera fields:**
- `camera_profile_id` (nullable) -- ALREADY EXISTS on clips table (Migration 1, migrations.rs line 44)
- `camera_device_id` (nullable) -- NEW, you will add via Migration 5

### Camera matching priority

Reference: Master plan section "Camera Matching"

1. Custom device by USB fingerprint -- 100% confidence
2. Custom device by serial number -- 95%
3. Custom device by make+model + strong heuristics -- 80%
4. Bundled profile by make+model -- 80%
5. Bundled profile by filename pattern -- 70%
6. Unknown -- generic profile silently (MUST NOT interrupt Simple mode)

---

## Implementation Steps (11 steps, dependency-correct order)

Reference: Master plan section "Implementation Order (Dependency-correct)"

Do these in order. Each step depends on previous steps.

---

### Step 1: Settings v2

Master plan ref: "Settings v2", "Backend Checklist #1", "Frontend Checklist #1-2", "Migration (v0.1.x -> v0.2.0)"

**What:** Expand settings struct, add migration from v1, add first-run wizard.

**Why first:** Every subsequent feature reads from settings (mode, feature flags, dev formulas, license cache).

**Backend changes** (`src-tauri/src/commands/settings.rs`):

Replace the current structs. The new `AppSettings`:

```rust
const SETTINGS_VERSION: u32 = 2;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum AppMode {
    Simple,
    Advanced,
}

impl Default for AppMode {
    fn default() -> Self { AppMode::Simple }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AppSettings {
    pub version: u32,                        // 2
    pub mode: AppMode,                       // simple | advanced
    pub first_run_completed: bool,
    pub theme: String,                       // "light" | "dark"
    pub default_project_path: Option<String>,
    pub recent_projects: Vec<RecentProject>,
    pub feature_flags: FeatureFlags,
    pub dev_menu: DevMenuSettings,
    pub license_state_cache: Option<LicenseStateCache>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RecentProject {
    pub path: String,
    pub name: String,
    pub last_opened: String,
    pub clip_count: i64,
    pub thumbnail_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FeatureFlags {
    pub screen_grabs: bool,
    pub face_detection: bool,
    pub best_clips: bool,
    pub cameras_tab: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DevMenuSettings {
    pub title_start_seconds: f64,    // default 5.0
    pub jl_blend_ms: u32,           // default 500
    pub score_weights: ScoreWeights,
    pub watermark_text: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ScoreWeights {
    pub scene: f64,     // default 0.25
    pub audio: f64,     // default 0.25
    pub sharpness: f64, // default 0.25
    pub motion: f64,    // default 0.25
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LicenseStateCache {
    pub license_type: String,  // "trial", "purchased", "rental", "dev"
    pub is_active: bool,
    pub days_remaining: Option<i32>,
}
```

**Settings migration logic** (in `get_app_settings`, NOT a database migration -- settings are in Tauri Store, not SQLite):

```
When loading settings:
  if version is missing or version < 2:
    map "personal" -> Simple
    map "pro" -> Advanced
    set first_run_completed = true   (existing user, skip wizard)
    set theme = "light"
    set version = 2
    initialize feature_flags with mode-appropriate defaults
    initialize dev_menu with defaults
    rename recent_libraries -> recent_projects
    save immediately
```

**Why existing users get `firstRunCompleted = true`:** They already have a library open and a mode chosen. The wizard is only for brand-new installs.

**Feature flag defaults by mode:**

| Flag | Simple | Advanced |
|------|--------|----------|
| screen_grabs | true | true |
| face_detection | false | true |
| best_clips | true | true |
| cameras_tab | false | true |

**Frontend changes** (`src/types/settings.ts`):

```typescript
type AppMode = 'simple' | 'advanced';  // was 'personal' | 'pro'

interface AppSettings {
  version: number;              // 2
  mode: AppMode;
  firstRunCompleted: boolean;
  theme: 'light' | 'dark';
  defaultProjectPath: string | null;
  recentProjects: RecentProject[];
  featureFlags: FeatureFlags;
  devMenu: DevMenuSettings;
  licenseStateCache: LicenseStateCache | null;
}

interface FeatureFlags {
  screenGrabs: boolean;
  faceDetection: boolean;
  bestClips: boolean;
  camerasTab: boolean;
}

interface DevMenuSettings {
  titleStartSeconds: number;
  jlBlendMs: number;
  scoreWeights: { scene: number; audio: number; sharpness: number; motion: number };
  watermarkText: string | null;
}

interface LicenseStateCache {
  licenseType: 'trial' | 'purchased' | 'rental' | 'dev';
  isActive: boolean;
  daysRemaining: number | null;
}

interface RecentProject {
  path: string;
  name: string;
  lastOpened: string;
  clipCount: number;
  thumbnailPath?: string;
}
```

**First-run wizard** (part of Step 1 -- must ship with Settings v2):

Reference: Master plan section "v0.2.0 Product Scope > Primary Deliverables" item 1

When `firstRunCompleted` is false, the app shows a wizard before anything else. The wizard gates the entire app -- nothing else is accessible until the wizard completes.

- Step 1: Pick Simple vs Advanced (radio buttons)
  - Simple: "One project, automatic camera matching, no setup needed"
  - Advanced: "Multiple projects, camera registration, feature toggles"
- Step 2 (Simple): Pick default project folder via native folder picker. Creates project at that path.
- Step 2 (Advanced): Go to Projects dashboard (the existing LibraryDashboard).
- On completion: set `firstRunCompleted = true`, save settings.

**Where the wizard goes in App.tsx:**

Currently `App.tsx` routes based on loading state, library state, unmounted state, and mode. The wizard must be the FIRST check after loading completes. Insert it before the library/mode checks (after the `isLoading` guard around line 242):

```typescript
// After loading completes, check wizard FIRST
if (settings && !settings.firstRunCompleted) {
  return <FirstRunWizard settings={settings} onComplete={handleWizardComplete} />;
}
// ... then existing routing logic (library check, unmounted check, mode check)
```

**Files to create:**
- `src/components/FirstRunWizard.tsx`

**Files to modify:**
- `src-tauri/src/commands/settings.rs` -- expand structs, add v1->v2 migration in load function
- `src/types/settings.ts` -- new interfaces
- `src/api/settings.ts` -- update API wrappers if signatures change
- `src/App.tsx` -- use new settings shape, gate on firstRunCompleted (show wizard when false)

**Gotchas for new devs:**
- Settings are NOT in SQLite. They are in a JSON file managed by the Tauri Store plugin. Do not confuse "settings migration" with "database migration." They are completely separate systems.
- The Tauri Store reads/writes individual keys, not the whole object at once. Look at how `get_app_settings` in `settings.rs` reads each key individually with fallbacks (lines 63-98).
- `serde(rename_all = "camelCase")` on Rust structs means `first_run_completed` in Rust becomes `firstRunCompleted` in JSON/TypeScript. This is already the pattern everywhere in this codebase.

**Verify:**
- [ ] App loads with v1 settings file, migrates to v2, persists correctly
- [ ] Old `personal` becomes `simple`, old `pro` becomes `advanced`
- [ ] Existing users get `firstRunCompleted = true` (no wizard)
- [ ] Fresh install shows first-run wizard before any other screen
- [ ] Wizard step 1 sets mode, step 2 sets project path (Simple) or goes to dashboard (Advanced)
- [ ] After wizard, `firstRunCompleted = true` and app proceeds normally
- [ ] Subsequent launches skip the wizard
- [ ] Feature flags initialized with correct defaults per mode

---

### Step 2: Unified Job Progress/Cancel Plumbing

Master plan ref: "Job/Progress standardization (REQUIRED)"

**What:** A single progress event contract that all long operations use.

**Why second:** Import dialog, export pipeline, and scoring all need the same progress reporting.

**Progress payload** (shared by all jobs):

```rust
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct JobProgress {
    pub job_id: String,
    pub phase: String,       // "discover", "copy", "metadata", "preview", "encode", etc.
    pub current: u64,
    pub total: u64,
    pub percent: f64,
    pub message: String,
    pub is_cancelled: bool,
    pub is_error: bool,
    pub error_message: Option<String>,
}
```

This matches the master plan's required progress payload exactly (section "Ingest & Import Dialog > Job/Progress standardization").

**Emit from Rust:**
```rust
// The Tauri AppHandle is needed to emit events
app_handle.emit("job-progress", &progress).map_err(|e| e.to_string())?;
```

**Listen in React:**
```typescript
import { listen } from '@tauri-apps/api/event';

// In a React component -- ALWAYS clean up the listener:
useEffect(() => {
  let cleanup: (() => void) | undefined;

  listen<JobProgress>('job-progress', (event) => {
    setProgress(event.payload);
  }).then((unlisten) => {
    cleanup = unlisten;
  });

  return () => {
    cleanup?.();
  };
}, []);
```

**Cancellation:** Use an `Arc<AtomicBool>` per job. When the frontend sends a cancel command, set the flag. The job runner checks it between phases. This is the same pattern for ingest, export, and scoring.

**Key change to existing code:** The `start_ingest` function in `lib.rs` (line 42) currently takes `State<DbState>` and returns `IngestResponse` synchronously. It does NOT have access to `AppHandle`, so it cannot emit events. To add progress, you need to either:
- Refactor `start_ingest` to accept `app: AppHandle` as a parameter, or
- Move it to a proper commands module file and use the `AppHandle` there

Note: `start_ingest` currently opens its OWN database connection (lines 44-45: `get_db_path` then `open_db`) instead of using the shared `DbState`. This is because ingest needs a separate connection for the long-running operation so it does not hold the Mutex lock. Keep this pattern for any long-running operation.

**Files to create:**
- `src-tauri/src/jobs/progress.rs` -- JobProgress struct + emit helper function
- `src/types/jobs.ts` -- TypeScript JobProgress interface
- `src/api/jobs.ts` -- cancel_job wrapper

**Files to modify:**
- `src-tauri/src/lib.rs` -- refactor start_ingest to accept AppHandle and use progress
- `src-tauri/src/jobs/runner.rs` -- integrate progress emission into job loop
- `src-tauri/src/jobs/mod.rs` -- add cancel_job command

**Gotchas for new devs:**
- Tauri events are one-way: Rust emits, TypeScript listens. This is different from commands (TypeScript calls, Rust responds). Events are for real-time updates; commands are for request/response.
- `listen()` returns a `Promise<UnlistenFn>`. You MUST call it in a React `useEffect` cleanup to prevent memory leaks. The pattern above handles the async setup correctly.
- `Arc<AtomicBool>` is the standard Rust pattern for cross-thread cancellation. Import from `std::sync::Arc` and `std::sync::atomic::{AtomicBool, Ordering}`. Use `Ordering::Relaxed` for the cancel flag.

**Verify:**
- [ ] Start an ingest job, observe progress events in browser console (open with Cmd+Opt+I in dev mode)
- [ ] Cancel mid-job, confirm it stops within one phase boundary
- [ ] Progress percent increases from 0 to 100

---

### Step 3: Licensing System

Master plan ref: "Licensing & Trial", "Soft lock behavior after trial expires", "Migration > Trial start"

**What:** Trial (14 days), Purchased ($99), Rental (key-based), Dev (internal).

**Why third:** Export watermarking, import gating, and dev menu all depend on license state.

**New dependency in Cargo.toml:**
```toml
keyring = "2"   # OS keychain for secure key storage
```

**License types:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum LicenseType {
    Trial,
    Purchased,
    Rental,
    Dev,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LicenseState {
    pub license_type: LicenseType,
    pub is_active: bool,
    pub trial_start: Option<String>,
    pub trial_days_remaining: Option<i32>,
    pub key_hash: Option<String>,  // hash of key, never the raw key in settings
}
```

**Key storage:** Store the license key in the OS keychain via the `keyring` crate. The settings JSON (`LicenseStateCache`) stores only a non-secret summary (type, is_active, days_remaining). Never store the raw key in settings.

**Trial start (from master plan "Migration" section):** On first v0.2.0 launch, if no valid license exists in keychain, record the current UTC date as trial start. Store the trial start date in the keychain (not settings) so it survives settings file deletion or corruption. Trial = 14 days from that date.

**Key validation (local, offline):**
- Keys are self-contained strings with embedded type and optional expiry
- Validate by checking a signature or HMAC (implementation detail -- your choice)
- No server calls ever (contract 13)
- Dev keys use prefix `DCAM-D-`
- Purchased keys use prefix `DCAM-P-`
- Rental keys use prefix `DCAM-R-`

**Soft lock enforcement (what to check, and where):**

| Gate | Check location | Behavior when expired |
|------|---------------|----------------------|
| Import button | Frontend: before opening import dialog | Show "Trial expired" message, block |
| Scoring queue | Backend: before creating score jobs | Return error |
| VHS Export | Backend: FFmpeg builder | Add watermark filter + scale to 720p max |
| Export Originals | NONE | Always allowed (non-hostage rule) |
| Camera registration | Backend: register_camera_device | Return error |

**Commands to add (4):**
```rust
get_license_state()         -> LicenseState
activate_license(key)       -> Result<LicenseState, String>
deactivate_license()        -> Result<(), String>
is_feature_allowed(feature) -> bool
```

**Key entry UI:** Accessible from two places:
1. Trial banner CTA -- "Enter License Key" button in the countdown banner
2. Dev Menu > License Tools -- full license management panel

The trial banner sits at the top of the app when in trial state.

**Files to create:**
- `src-tauri/src/licensing/mod.rs` -- license validation, keychain ops, trial tracking
- `src-tauri/src/commands/licensing.rs` -- 4 Tauri commands
- `src/types/licensing.ts` -- TypeScript interfaces
- `src/api/licensing.ts` -- API wrappers
- `src/components/TrialBanner.tsx` -- trial countdown bar
- `src/components/modals/LicenseKeyModal.tsx` -- key entry modal

**Files to modify:**
- `src-tauri/Cargo.toml` -- add `keyring` dependency
- `src-tauri/src/lib.rs` -- add `pub mod licensing;`, register new commands
- `src-tauri/src/commands/mod.rs` -- add `pub mod licensing;` and re-export

**Gotchas for new devs:**
- The `keyring` crate uses the OS keychain: Keychain on macOS, Credential Manager on Windows, Secret Service on Linux. You do not need to handle per-platform logic yourself -- the crate abstracts it.
- Never store the raw key in the Tauri Store settings file. Only store a summary cache (type + active status + days remaining). The raw key goes in the keychain only.
- The trial start date also goes in the keychain (not settings) so it survives settings file deletion.
- Contract 13 means NO network calls for validation. The key format must be self-validating (e.g., HMAC signature embedded in the key).

**Verify:**
- [ ] Fresh install starts trial, shows 14 days remaining
- [ ] After trial expires (mock date for testing): import is blocked with clear message
- [ ] After trial expires: new scoring/analysis jobs blocked
- [ ] After trial expires: rendered export has watermark AND 720p cap
- [ ] After trial expires: export originals (file copy) always works
- [ ] Valid purchased key activates correctly
- [ ] Valid rental key activates correctly
- [ ] Dev key (`DCAM-D-...`) enables raw SQL in dev menu
- [ ] Invalid key shows error, does not activate
- [ ] Trial banner visible with days remaining and "Enter License Key" CTA
- [ ] Key entry modal accessible from trial banner CTA
- [ ] Key entry modal accessible from Dev Menu > License Tools
- [ ] After activation, trial banner disappears
- [ ] Keychain storage works on macOS, Windows, Linux

---

### Step 4: VHS Export MVP

Master plan ref: "VHS Edit System (Export)"

**What:** Build a timeline from selected clips, crossfade between them with J&L audio blending, optional title overlay, render via FFmpeg.

**Why fourth:** This is the core product feature. Licensing gates it, and the import dialog references it.

**The VHS pipeline concept:**
1. User picks clips (by date, event, favorites, score threshold, or all)
2. User picks order (chronological, score desc/asc, shuffle)
3. User optionally adds title text
4. App builds an FFmpeg filtergraph that crossfades video and audio between clips
5. FFmpeg renders the output file
6. If trial-expired: watermark burned in + 720p max resolution

**Title overlay (from master plan):**
- Optional text entered in export dialog
- Appears at 5 seconds into the timeline (configurable via dev menu: `devMenu.titleStartSeconds`)
- Duration: 3 seconds total (0.5s fade in, 2s hold, 0.5s fade out)
- Centered text with subtle semi-transparent background plate
- FFmpeg `drawtext` filter

**J&L audio blending (from master plan):**
- Default blend duration: 500ms (configurable via dev menu: `devMenu.jlBlendMs`)
- FFmpeg `xfade` filter for video crossfade
- FFmpeg `acrossfade` filter for audio crossfade
- Before blending: normalize all audio to consistent sample rate (48kHz) and channel layout (stereo)
- Handle clips with no audio track: generate silence track

**FFmpeg filtergraph strategy:**

For N clips, you need N-1 crossfade operations. This chains xfade outputs:

```
Input streams: [0:v], [1:v], [2:v], ...

Video chain (3 clips, 0.5s blend):
[0:v][1:v]xfade=transition=fade:duration=0.5:offset=T1[v01];
[v01][2:v]xfade=transition=fade:duration=0.5:offset=T2[vout];

Audio chain (parallel):
[0:a][1:a]acrossfade=d=0.5:c1=tri:c2=tri[a01];
[a01][2:a]acrossfade=d=0.5:c1=tri:c2=tri[aout];
```

Where T1 = duration_of_clip_0 - 0.5, T2 = T1 + duration_of_clip_1 - 0.5, etc.

This is the hardest FFmpeg work in the app. Key gotchas:
- All clips must be conformed to the same FPS and resolution before xfade
- Audio must be conformed to same sample rate (48kHz) and channel layout (stereo)
- Missing audio needs a silent audio track injected via `anullsrc`
- The offset for each xfade is cumulative (previous durations minus overlap)
- Use proxy files (720p H.264) as input when available -- faster and already normalized

**Conform filter (applied to every input before crossfade):**
```
scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2,fps=30,setsar=1
```

This forces every clip to exactly 1920x1080@30fps with pillarboxing/letterboxing as needed. Without this, xfade WILL fail on resolution/fps mismatches.

**Watermark + 720p cap (when license expired):**
```
drawtext=text='Dad Cam Trial':fontsize=24:fontcolor=white@0.5:x=(w-tw)/2:y=h-th-20
scale='min(1280,iw)':'min(720,ih)':force_original_aspect_ratio=decrease
```

**Selection modes:**

Reference: Master plan section "VHS Edit System > Selection modes"

| Mode | SQL approach | Availability |
|------|-------------|-------------|
| By Date range | `WHERE recorded_at BETWEEN ? AND ?` | All modes |
| By Event | `JOIN event_clips ON ...` | All modes |
| Favorites only | `JOIN clip_tags WHERE tag = 'favorite'` | All modes |
| Score threshold | `JOIN clip_scores WHERE overall_score >= ?` | Advanced only |
| All clips | No filter | All modes |

**Ordering options:**

Reference: Master plan section "VHS Edit System > Ordering"

- Chronological (default): `ORDER BY recorded_at ASC`
- Score descending: `ORDER BY overall_score DESC`
- Score ascending: `ORDER BY overall_score ASC`
- Shuffle: deterministic random using a seed

**Export history** (new table, Migration 4):

Reference: Master plan section "VHS Edit System > Export history"

```sql
CREATE TABLE export_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    library_id INTEGER NOT NULL REFERENCES libraries(id),
    output_path TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    selection_mode TEXT NOT NULL,     -- 'date_range', 'event', 'favorites', 'score', 'all'
    selection_params TEXT DEFAULT '{}', -- JSON
    ordering TEXT NOT NULL DEFAULT 'chronological',
    title_text TEXT,
    resolution TEXT,
    is_watermarked INTEGER NOT NULL DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'pending',
    duration_ms INTEGER,
    file_size_bytes INTEGER,
    clip_count INTEGER,
    error_message TEXT,
    completed_at TEXT
);
```

Migration numbering: This is Migration 4. It goes after the existing 3 migrations in `migrations.rs`. Add it as the 4th element in the `MIGRATIONS` array. The migration system uses `PRAGMA user_version` and applies all pending migrations in order.

**Commands to add (3):**
```rust
start_vhs_export(params: VhsExportParams) -> Result<String, String>   // returns job_id
get_export_history(limit: u32) -> Result<Vec<ExportHistoryEntry>, String>
cancel_export(job_id: String) -> Result<(), String>
```

**Frontend: Export dialog UI**

Navigation path: LibraryView toolbar currently has an "Import Footage" button. Add a "VHS Export" button next to it. Clicking opens ExportDialog as a modal or full sub-view.

The export dialog contains:
- Selection mode dropdown (Date range, Event, Favorites, Score threshold [Advanced only], All)
- Sub-controls per mode (date picker, event picker, threshold slider)
- Ordering dropdown (Chronological, Score desc, Score asc, Shuffle)
- Title text input (optional)
- Output path picker (native save dialog)
- "Export" button
- Progress bar (uses Step 2 progress system)
- Export history list below

**Files to create:**
- `src-tauri/src/export/mod.rs` -- export orchestration
- `src-tauri/src/export/timeline.rs` -- clip selection + ordering queries
- `src-tauri/src/export/ffmpeg_builder.rs` -- filtergraph construction (the hard part)
- `src-tauri/src/export/watermark.rs` -- watermark + 720p cap logic
- `src-tauri/src/commands/export.rs` -- 3 Tauri commands
- `src/components/ExportDialog.tsx` -- export UI
- `src/components/ExportHistory.tsx` -- history list
- `src/types/export.ts` -- TypeScript types
- `src/api/export.ts` -- API wrappers

**Files to modify:**
- `src-tauri/src/db/migrations.rs` -- add Migration 4 (export_history table)
- `src-tauri/src/lib.rs` -- add `pub mod export;`, register 3 new commands
- `src-tauri/src/commands/mod.rs` -- add `pub mod export;`
- `src/components/LibraryView.tsx` -- add "VHS Export" button in toolbar, wire ExportDialog

**Gotchas for new devs:**
- The `ffmpeg-sidecar` crate runs FFmpeg as a subprocess. You build a command with arguments and execute it. Look at how `preview/proxy.rs` builds its FFmpeg command for a working example in this codebase.
- FFmpeg filtergraph syntax is notoriously tricky. Test with 2 clips first, then 3, then N. The chaining of xfade outputs (`[v01]`, `[v012]`, etc.) gets complex fast.
- `anullsrc` generates silence. Use it when a clip has no audio stream: `anullsrc=r=48000:cl=stereo`.
- The `xfade` offset parameter is the timestamp (in seconds) where the crossfade STARTS in the output timeline. It is NOT relative to the clip. Calculate it as: sum of all previous clip durations minus sum of all previous overlap durations.
- The `ffmpeg-sidecar` crate can auto-download FFmpeg binaries (see `tools.rs` for the resolution order: env override > sidecar > macOS Resources > PATH fallback). This is how the app meets contract 18 (bundle tools). On production builds, FFmpeg is bundled as a Tauri sidecar resource.

**Verify:**
- [ ] Select 3+ clips by date range, export with title, plays back correctly
- [ ] Audio crossfades smooth (no pops or silence gaps)
- [ ] Title appears at 5 seconds, fades in/out over 3 seconds
- [ ] Mixed codecs/resolutions handled (no FFmpeg errors)
- [ ] Clips with no audio track do not crash the pipeline
- [ ] Export history records created with correct metadata
- [ ] Watermark visible when trial expired
- [ ] 720p cap enforced when trial expired
- [ ] Progress events emitted, cancel works mid-export
- [ ] Chronological, score desc, score asc, shuffle orderings all work

---

### Step 5: Camera System MVP

Master plan ref: "Camera Matching", "Core Data Model > Cameras: profile vs device"

**What:** Bundled camera profile database + custom "Dad Cam" device registration + matching engine.

**Why fifth:** The import dialog (Step 6) shows camera breakdown, which requires the matching engine.

**Existing state:** `camera/mod.rs` already has `CameraProfile`, `MatchRules`, `TransformRules`, `match_camera_profile()`, and 3 default profiles (Sony Handycam, Canon DSLR, Panasonic MiniDV). The `clips` table already has `camera_profile_id`. What is missing:
- `camera_device_id` column on clips (NEW)
- `camera_devices` table (NEW)
- Device matching logic (NEW)
- Bundled profile database file (NEW -- can start empty, system works without it)

**Database migration (Migration 5):**

```sql
CREATE TABLE camera_devices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    uuid TEXT NOT NULL UNIQUE,
    profile_id INTEGER REFERENCES camera_profiles(id),
    serial_number TEXT,
    fleet_label TEXT,           -- e.g. "DadCam-12"
    usb_fingerprints TEXT,     -- JSON array of USB identifiers
    rental_notes TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

ALTER TABLE clips ADD COLUMN camera_device_id INTEGER REFERENCES camera_devices(id);

CREATE INDEX idx_camera_devices_uuid ON camera_devices(uuid);
CREATE INDEX idx_clips_camera_device ON clips(camera_device_id);
```

**Bundled profile database:**
- File: `resources/cameras/canonical.json`
- Can start empty (`[]`) -- the system must work without it
- Source TBD -- fill with real camera data as available
- Loaded at startup, profiles inserted into `camera_profiles` table if not already present

**Custom device database:**
- File: `~/.dadcam/custom_cameras.json`
- Created by Dev Menu registration flow
- Contains Camera Device records with profiles and USB fingerprints

**Registration flow (Dev Menu, Step 9):**
1. User provides sample clips from the camera
2. System extracts metadata (make, model, codec, filename pattern)
3. If USB connected, capture USB fingerprint (best-effort, OS-specific)
4. User assigns fleet label and notes
5. System creates camera_device record linked to a profile (existing or new)

**Key rule:** Unknown cameras must NOT interrupt Simple mode flow. No popups, no errors. Silently fall back to generic.

**Commands to add (6):**
```rust
list_camera_profiles() -> Vec<CameraProfile>
list_camera_devices() -> Vec<CameraDevice>
register_camera_device(params) -> Result<CameraDevice, String>
match_camera(clip_id) -> CameraMatchResult
import_camera_db(json_path) -> Result<u32, String>   // returns count imported
export_camera_db(output_path) -> Result<(), String>
```

**Files to create:**
- `src-tauri/src/camera/devices.rs` -- device management + USB fingerprinting
- `src-tauri/src/camera/matcher.rs` -- unified matching engine (refactor existing mod.rs)
- `src-tauri/src/camera/bundled.rs` -- load canonical.json
- `src-tauri/src/commands/cameras.rs` -- 6 Tauri commands
- `resources/cameras/canonical.json` -- bundled DB (can start as `[]`)
- `src/types/cameras.ts` -- TypeScript types
- `src/api/cameras.ts` -- API wrappers

**Files to modify:**
- `src-tauri/src/db/migrations.rs` -- add Migration 5
- `src-tauri/src/camera/mod.rs` -- refactor to use new matcher
- `src-tauri/src/ingest/mod.rs` -- call device matcher during ingest, set camera_device_id
- `src-tauri/src/lib.rs` -- register 6 camera commands
- `src-tauri/src/commands/mod.rs` -- add cameras module

**Gotchas for new devs:**
- `ALTER TABLE clips ADD COLUMN` in SQLite does NOT support `NOT NULL` without a default. Since `camera_device_id` is nullable, this is fine. If you needed a non-nullable column, you would have to recreate the table (SQLite limitation).
- The existing `camera/mod.rs` has `match_camera_profile()` that returns a profile match. You need a new `match_camera()` function that tries device matching FIRST, then falls back to profile matching (following the 6-level priority list above).
- The `resources/` directory is for Tauri sidecar resources. Files here get bundled with the app binary. Use `tauri::api::path::resolve_path()` to locate them at runtime.

**Verify:**
- [ ] Ingest works with empty canonical.json (generic fallback)
- [ ] Known camera model matched by make+model from ffprobe/exiftool metadata
- [ ] Custom device created via sample clips
- [ ] USB fingerprint captured on macOS (best-effort, no crash on failure)
- [ ] Clip records have correct device_id and profile_id after import
- [ ] Unknown cameras fall back silently in Simple mode

---

### Step 6: Import Dialog + Sidecars

Master plan ref: "Ingest & Import Dialog", "Sidecars & Metadata"

**What:** Replace the current bare "Import Footage" flow with a proper dialog: folder picker, event assignment, progress, summary. Write per-clip sidecar JSON files during ingest.

**Why sixth:** Depends on Step 2 (progress), Step 3 (license gate), and Step 5 (camera matching).

**Current state:** Import is triggered via `WelcomeDashboard.tsx` and `LibraryView.tsx`. It opens a native folder picker, calls `start_ingest` in `lib.rs`, and shows a simple status message with counts. No progress bar, no event assignment, no camera feedback, no sidecar output.

**Import pipeline (per file, 8 steps from master plan):**
1. Discover files (with resumable manifest via ingest_files table)
2. Copy or reference into project (depends on library ingest_mode)
3. Hash (BLAKE3 fast hash)
4. Extract metadata (ffprobe + exiftool)
5. Camera match -- set device/profile IDs on clip record
6. Generate preview assets (proxy, thumbnail, sprite)
7. Insert DB records + write sidecar JSON
8. If event chosen -- insert `event_clips` rows

Every step emits progress events (Step 2). If the process crashes, the resumable manifest picks up where it left off (contract 16).

**Sidecars:**

Reference: Master plan section "Sidecars & Metadata"

Written during step 7 for each clip.

Location: `.dadcam/sidecars/<clip_id>.json`

NEVER write sidecars next to originals (master plan: "Never write next to originals by default").

Sidecar contents (JSON):
```json
{
  "original_file_path": "/path/to/original.mts",
  "file_hash_blake3": "abc123...",
  "metadata_snapshot": { },
  "camera_match": {
    "device_id": null,
    "profile_id": 4,
    "confidence": 0.8,
    "reason": "make+model match"
  },
  "ingest_timestamps": {
    "discovered_at": "2026-01-28T...",
    "copied_at": "2026-01-28T...",
    "indexed_at": "2026-01-28T..."
  },
  "derived_asset_paths": {
    "proxy": ".dadcam/proxies/...",
    "thumb": ".dadcam/thumbs/...",
    "sprite": ".dadcam/sprites/..."
  },
  "rental_audit": null
}
```

**New Import Dialog flow:**
1. User clicks "Import Footage"
2. License check: if trial expired, show message and block
3. Dialog opens with folder picker
4. Event assignment dropdown:
   - "No event" (default)
   - Existing events (from `get_events()`)
   - "Create new event..." (inline name input)
5. User clicks "Start Import"
6. Live progress (Step 2 system):
   - Phase indicators: discovering / copying / indexing / generating previews
   - Current / total counts
   - Percent bar
   - Cancel button
7. Summary screen:
   - Clips imported count
   - Camera breakdown (Advanced mode only): "12 clips from Sony HDR-CX405, 3 from Unknown"
   - Event assignment summary
   - "Done" button

**Backend changes:**

Modify `start_ingest` in `lib.rs` (or move to a new `commands/import.rs`) to accept optional parameters:

```rust
pub struct IngestParams {
    pub source_path: String,
    pub library_path: String,
    pub event_id: Option<i64>,           // existing event
    pub new_event_name: Option<String>,  // create inline
}
```

After ingest completes:
- If `event_id` provided: insert `event_clips` rows for all new clips
- If `new_event_name` provided: create event first, then insert rows
- Emit progress events throughout
- Write sidecar JSON for each clip
- Return summary with camera breakdown stats

**Files to create:**
- `src/components/ImportDialog.tsx` -- full import dialog
- `src-tauri/src/ingest/sidecar.rs` -- sidecar write logic

**Files to modify:**
- `src-tauri/src/ingest/mod.rs` -- accept event params, emit progress, call sidecar writer
- `src-tauri/src/lib.rs` -- update start_ingest signature (or create commands/import.rs)
- `src/components/WelcomeDashboard.tsx` -- use ImportDialog instead of direct ingest
- `src/components/LibraryView.tsx` -- wire up ImportDialog

**Gotchas for new devs:**
- The `.dadcam/sidecars/` directory does not exist yet. You must add it to `init_library_folders()` in `src-tauri/src/db/mod.rs`. That function currently creates proxies/, thumbs/, sprites/, and exports/. Add sidecars/ to the list.
- Event creation uses the existing `create_event` function in `commands/events.rs`. You can call the underlying schema function directly from Rust (no need to go through IPC).
- The existing ingest already uses `ingest_files` table for per-file crash recovery. Each file has its own status row, so if the app crashes mid-import, restarting picks up from the last incomplete file.

**Verify:**
- [ ] Import with "No event" works as before
- [ ] Import with existing event creates correct event_clips join rows
- [ ] Import with inline new event creates event then links clips
- [ ] Progress bar updates in real time with phase labels
- [ ] Cancel mid-import stops cleanly
- [ ] Summary shows correct clip count
- [ ] Camera breakdown shows in Advanced mode (hidden in Simple)
- [ ] Import blocked when trial expired (soft lock)
- [ ] Sidecar JSON written to `.dadcam/sidecars/` (not next to originals)
- [ ] Sidecar contains: original path, hash, metadata, camera match, timestamps, derived paths
- [ ] Import survives crash/interruption and resumes (contract 16)
- [ ] Camera detection never blocks import (generic fallback works)

---

### Step 7: LeftNav Updates

Master plan ref: "Frontend Checklist #7"

**What:** Add Favorites nav link and gate Cameras tab.

**Why seventh:** Small UI change, depends on settings v2 feature flags.

**Favorites link:**
- Add "Favorites" item to LibrarySection in LeftNav
- Clicking it sets the filter to "favorites" in the existing ClipGrid
- Do NOT create a separate FavoritesView component (decided in v0.1.65)
- Navigate to the clips view with the favorites filter pre-applied

**Cameras tab:**
- Only visible when `featureFlags.camerasTab` is true AND mode is `advanced`
- Shows list of cameras grouped by device (known) and profile (matched)
- Unknown camera bucket at bottom

**Files to modify:**
- `src/components/nav/LibrarySection.tsx` -- add Favorites link
- `src/components/LeftNav.tsx` -- add Cameras section (conditional on flags + mode)
- `src/components/LibraryView.tsx` -- handle favorites nav click (set filter state)

**Files to create:**
- `src/components/CamerasView.tsx` -- cameras list view (if tab warrants its own component)

**Verify:**
- [ ] Favorites link in nav filters clips to favorites only
- [ ] Cameras tab visible in Advanced mode with camerasTab flag on
- [ ] Cameras tab hidden in Simple mode
- [ ] Cameras tab hidden when camerasTab flag off in Advanced mode

---

### Step 8: Feature Toggles (Advanced Only)

Master plan ref: "Frontend Checklist #8"

**What:** Settings page shows feature toggle switches only in Advanced mode. Simple mode hides them entirely.

**Files to modify:**
- `src/components/SettingsView.tsx` -- add feature toggles section, gate on `mode === 'advanced'`

**Toggle behavior:**
- When face_detection is off: scoring does not queue face detection jobs
- When cameras_tab is off: Cameras tab hidden from LeftNav
- When best_clips is off: Best Clips section hidden
- Toggles persist to settings immediately on change

**Verify:**
- [ ] Toggles visible only in Advanced mode
- [ ] Toggles hidden entirely in Simple mode (not just disabled -- hidden)
- [ ] Toggling cameras_tab off hides Cameras from LeftNav
- [ ] Toggle changes persist across app restart

---

### Step 9: Dev Menu

Master plan ref: "Dev Menu (v0.2.0 requirement)"

**What:** Hidden developer panel with formulas, camera DB tools, license tools, and debug utilities.

**Access (two methods, master plan):**
- Hotkey: Cmd+Shift+D (macOS) / Ctrl+Shift+D (Windows/Linux)
- Easter egg: click version number 7 times in Settings

**Sections (4, from master plan):**

**1. Formulas**
- Title start time (seconds) -- edits `devMenu.titleStartSeconds`
- J/L blend duration (ms) -- edits `devMenu.jlBlendMs`
- Score weights (scene/audio/sharpness/motion) -- edits `devMenu.scoreWeights`
- Watermark text override -- edits `devMenu.watermarkText`

**2. Camera Database**
- View bundled profiles (full table: make, model, match rules)
- View custom devices (full table with edit/delete)
- Register new device (from sample clips; USB best-effort)
- Import camera JSON (native file picker) / Export camera JSON (native save dialog)

**3. License Tools**
- View current license state
- Inline key activation (text input + Activate button, with validation feedback)
- Generate rental keys (batch, 1-100) -- for fleet owners
- Clear/reset trial (dev key only)

**4. Debug**
- Live log viewer (listens for job-progress events, displays last 200 lines)
- FFmpeg test (run `ffmpeg -version` and show output)
- Database stats (table counts, db size, migration version via `get_db_stats`)
- Clear caches (delete proxies/thumbs/sprites, keep originals)
- Export database (copy `.dadcam/dadcam.db` to chosen location via native save dialog)
- Export EXIF dump (clip ID input + native save dialog, extracts raw exiftool JSON)
- Raw SQL query (Dev key only -- gated behind `DCAM-D-` license prefix)

**Backend commands to add (7):**
```rust
test_ffmpeg() -> Result<String, String>              // returns ffmpeg version string
clear_caches() -> Result<ClearResult, String>        // returns counts of deleted files
export_database(output_path: String) -> Result<(), String>
export_exif_dump(clip_id: i64, output_path: String) -> Result<(), String>
execute_raw_sql(query: String) -> Result<Vec<serde_json::Value>, String>  // dev key only
generate_rental_keys(count: u32) -> Result<Vec<String>, String>
get_db_stats() -> Result<DbStats, String>            // table counts, db size, migration version
```

Raw SQL must verify the license is Dev type before executing. Return an error otherwise.

**Files to create:**
- `src/components/DevMenu.tsx` -- main dev menu panel
- `src/components/dev/FormulasEditor.tsx`
- `src/components/dev/CameraDbManager.tsx`
- `src/components/dev/LicenseTools.tsx`
- `src/components/dev/DebugTools.tsx`
- `src-tauri/src/commands/devmenu.rs` -- 7 Tauri commands

**Files to modify:**
- `src/App.tsx` -- add keyboard listener for Cmd/Ctrl+Shift+D
- `src/components/SettingsView.tsx` -- add version click counter for easter egg
- `src-tauri/src/lib.rs` -- register 7 dev menu commands
- `src-tauri/src/commands/mod.rs` -- add devmenu module

**Gotchas for new devs:**
- Use `document.addEventListener('keydown', handler)` in a `useEffect` for the hotkey. Check `e.metaKey` (macOS) or `e.ctrlKey` (Windows/Linux) + `e.shiftKey` + `e.key === 'D'`.
- The `clear_caches` function should delete files in `.dadcam/proxies/`, `.dadcam/thumbs/`, `.dadcam/sprites/` but NEVER touch `.dadcam/dadcam.db` or `originals/`. This is contract 12.
- For `export_database`, use `std::fs::copy()` to copy the .db file. Make sure to close any open connections first or use SQLite's backup API.
- `execute_raw_sql` must check the license type BEFORE running the query. Call `get_license_state()` and verify it returns `Dev`. This is a security gate.

**Verify:**
- [ ] Hotkey opens dev menu on macOS (Cmd+Shift+D) and Windows/Linux (Ctrl+Shift+D)
- [ ] Easter egg (7 clicks on version in Settings) opens dev menu
- [ ] Formula changes persist and affect export behavior (title timing, blend duration)
- [ ] Camera DB shows full profile table and device table (not just counts)
- [ ] Camera DB import (native file picker) / export (native save dialog) round-trips correctly
- [ ] License Tools shows inline key activation with validation feedback
- [ ] FFmpeg test shows version string
- [ ] Database stats shows table counts and migration version
- [ ] Clear caches deletes proxies/thumbs/sprites (not originals, not database)
- [ ] Export database copies .db file to chosen location via native save dialog
- [ ] Export EXIF dump: clip ID input + save dialog, extracts full exiftool JSON
- [ ] Live log viewer displays job-progress events (last 200 lines)
- [ ] Raw SQL gated behind Dev key -- returns error without it

---

### Step 10: USB Registration (Best-Effort)

Master plan ref: "Backend Checklist #8"

**What:** When a USB camera is connected, attempt to read USB device identifiers for fingerprinting.

**Why late:** OS-specific, unreliable, and has a complete fallback.

**macOS:** `system_profiler SPUSBDataType -xml` plist output parsing (stable across macOS versions)
**Windows:** PowerShell `Get-CimInstance Win32_PnPEntity` with regex VID/PID extraction (future-proof, replaces deprecated `wmic`)
**Linux:** Read from `/sys/bus/usb/devices/`

**Key rule:** If USB detection fails for any reason (permissions, unsupported OS, device not found), fall back silently to manual registration via sample clips (Dev Menu). Never block the user. Never error in Simple mode.

**Files to modify:**
- `src-tauri/src/camera/devices.rs` -- add USB fingerprint capture functions per OS

**Gotchas for new devs:**
- Use `#[cfg(target_os = "macos")]`, `#[cfg(target_os = "windows")]`, `#[cfg(target_os = "linux")]` for platform-specific code blocks. Rust compiles only the matching block for each target.
- Wrap ALL USB detection in `std::panic::catch_unwind` and return `Option<String>`. USB detection is best-effort. A panic here would crash the app.
- `system_profiler SPUSBDataType -xml` gives parseable XML plist on macOS -- use this instead of plain-text output for stable parsing across macOS versions.
- On Windows, use PowerShell `Get-CimInstance` instead of deprecated `wmic`. Extract VID/PID with regex, not fixed-offset string slicing.
- Filter out root hubs and deduplicate fingerprint entries on all platforms.

**Verify:**
- [ ] USB fingerprint captured on macOS (best-effort, using -xml plist)
- [ ] USB fingerprint captured on Windows (best-effort, using PowerShell)
- [ ] USB failure falls back silently (no popup, no error)
- [ ] Root hubs filtered out, fingerprints deduplicated
- [ ] Registration still works via sample clips when USB unavailable

---

### Step 11: Theme Toggle Wiring (Advanced Only)

Master plan ref: "Frontend Checklist #9"

**What:** Advanced mode users can toggle between light and dark themes.

**Current state:** `App.css` already has `:root.dark-mode { ... }` CSS class with dark theme variables (added in v0.1.64). The toggle just needs to be wired to settings.

**Simple mode:** Light only, no toggle shown.
**Advanced mode:** Toggle in Settings, applies `.dark-mode` class on document root.

**Files to modify:**
- `src/components/SettingsView.tsx` -- add theme toggle (visible only when `mode === 'advanced'`)
- `src/App.tsx` -- on settings load, apply/remove `dark-mode` class: `document.documentElement.classList.toggle('dark-mode', settings.theme === 'dark')`

**Verify:**
- [ ] Theme toggle visible in Advanced mode
- [ ] Theme toggle hidden in Simple mode
- [ ] Selecting dark mode applies `.dark-mode` class, UI switches
- [ ] Theme persists across app restart

---

## Terminology Rename (Do Last)

The Settings v2 migration (Step 1) changes the stored enum values and data structures -- `AppMode` becomes `simple | advanced`, and `RecentLibrary` becomes `RecentProject` in Step 1. Those renames are required for compilation.

What IS deferred to the very end:
- UI text strings ("Personal mode" -> "Simple mode", "Library" -> "Project" in button labels)
- CSS class names containing "personal" or "pro"
- Internal variable names in TypeScript (e.g., `isPersonalMode` -> `isSimpleMode`)

Do the cosmetic rename last because:
1. It touches many files (biggest diff in the release)
2. It delivers zero functional value (purely cosmetic)
3. It is most likely to cause merge conflicts if done early

The UI can display "Simple" / "Advanced" immediately using the new enum values from Step 1. Only the grep-and-replace of leftover variable names and CSS classes waits until the end.

---

## Conventions to Follow

### Rust Backend

Source: Existing patterns in `src-tauri/src/commands/*.rs`

- All Tauri commands return `Result<T, String>` (Tauri IPC requirement -- the error type MUST be String)
- Database access pattern: `db.0.lock().map_err(|e| e.to_string())?` then `conn.as_ref().ok_or("No library open")?`
- Use `#[serde(rename_all = "camelCase")]` on all response structs (converts Rust snake_case to JS camelCase automatically)
- Forward-only migrations in `migrations.rs` -- never edit a shipped migration
- New constants go in `constants.rs`
- New error variants go in `error.rs` DadCamError enum
- New modules declared in `lib.rs` with `pub mod module_name;`
- New commands registered in the `generate_handler![]` macro in `lib.rs`

**Pattern for a new Tauri command:**
```rust
// In src-tauri/src/commands/mymodule.rs
use tauri::State;
use serde::{Deserialize, Serialize};
use super::DbState;

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct MyResponse {
    pub some_field: String,
}

#[tauri::command]
pub fn my_command(db: State<'_, DbState>) -> Result<MyResponse, String> {
    let conn_guard = db.0.lock().map_err(|e| e.to_string())?;
    let conn = conn_guard.as_ref().ok_or("No library open")?;
    // ... do work with conn ...
    Ok(MyResponse { some_field: "value".into() })
}
```

**Adding a new command module (full 5-step process):**
1. Create `src-tauri/src/commands/mymodule.rs` with your command functions
2. Add `pub mod mymodule;` to `src-tauri/src/commands/mod.rs`
3. Add `pub use mymodule::*;` to the re-exports in `mod.rs`
4. Add `commands::my_command` to the `generate_handler![]` list in `lib.rs`
5. If it needs a new top-level module (like `licensing/`), also add `pub mod licensing;` to `lib.rs`

### TypeScript Frontend

Source: Existing patterns in `src/api/*.ts`, `src/types/*.ts`, `src/components/*.tsx`

- Types in `src/types/` (one file per domain)
- API wrappers in `src/api/` (one file per domain)
- Components in `src/components/` (flat or in subdirectories for groups like `nav/`, `modals/`, `dev/`)
- Single stylesheet: `src/App.css` (Braun Design Language CSS variables)
- No animated loaders (Braun spec D.10) -- text or static progress only
- No pure `#FFF` or `#000` -- use CSS variables
- Max border-radius: 8px (Braun spec)
- 8pt spacing grid

**Pattern for calling a Tauri command:**
```typescript
// In src/api/mymodule.ts
import { invoke } from '@tauri-apps/api/core';

export interface MyResponse {
  someField: string;
}

export async function myCommand(): Promise<MyResponse> {
  return invoke<MyResponse>('my_command');
}
```

**Pattern for listening to Tauri events (with proper cleanup):**
```typescript
import { listen } from '@tauri-apps/api/event';

// In a React component:
useEffect(() => {
  let cleanup: (() => void) | undefined;

  listen<JobProgress>('job-progress', (event) => {
    setProgress(event.payload);
  }).then((unlisten) => {
    cleanup = unlisten;
  });

  return () => {
    cleanup?.();
  };
}, []);
```

### CSS Variables (Braun Design Language)

Source: `src/App.css`

Key tokens already defined:
- `--color-canvas`, `--color-surface`, `--color-text`
- `--color-accent` (amber: #f59e0b)
- `--radius-sm` (4px), `--radius-md` (6px), `--radius-lg` (8px)
- `--space-xs` through `--space-xxl`
- Dark mode: `:root.dark-mode { ... }` overrides all color variables

### Changelog

After every change, update `changelog.md`. Format:
```
0.1.XX -- Short Title

- One line per change
- No AI/Claude mentions
- No emojis
```

Only bump `0.1.X` -- major version bumps are user-only decision.

---

## New Files Summary (All Steps)

### Rust (src-tauri/src/)

| File | Step | Purpose |
|------|------|---------|
| `jobs/progress.rs` | 2 | JobProgress struct + emit helpers |
| `licensing/mod.rs` | 3 | License validation, keychain, trial |
| `commands/licensing.rs` | 3 | 4 license commands |
| `export/mod.rs` | 4 | Export orchestration |
| `export/timeline.rs` | 4 | Clip selection + ordering |
| `export/ffmpeg_builder.rs` | 4 | FFmpeg filtergraph construction |
| `export/watermark.rs` | 4 | Watermark + 720p cap |
| `commands/export.rs` | 4 | 3 export commands |
| `camera/devices.rs` | 5 | Device management + USB |
| `camera/matcher.rs` | 5 | Unified matching engine |
| `camera/bundled.rs` | 5 | Load canonical.json |
| `commands/cameras.rs` | 5 | 6 camera commands |
| `ingest/sidecar.rs` | 6 | Sidecar JSON writer |
| `commands/devmenu.rs` | 9 | 7 dev menu commands |

### TypeScript (src/)

| File | Step | Purpose |
|------|------|---------|
| `components/FirstRunWizard.tsx` | 1 | First-run wizard |
| `types/jobs.ts` | 2 | JobProgress type |
| `api/jobs.ts` | 2 | Cancel job wrapper |
| `types/licensing.ts` | 3 | License types |
| `api/licensing.ts` | 3 | License API wrappers |
| `components/TrialBanner.tsx` | 3 | Trial countdown bar |
| `components/modals/LicenseKeyModal.tsx` | 3 | Key entry modal |
| `components/ExportDialog.tsx` | 4 | VHS export UI |
| `components/ExportHistory.tsx` | 4 | Export history list |
| `types/export.ts` | 4 | Export types |
| `api/export.ts` | 4 | Export API wrappers |
| `types/cameras.ts` | 5 | Camera types |
| `api/cameras.ts` | 5 | Camera API wrappers |
| `components/ImportDialog.tsx` | 6 | Full import dialog |
| `components/CamerasView.tsx` | 7 | Cameras list view |
| `components/DevMenu.tsx` | 9 | Dev menu panel |
| `components/dev/FormulasEditor.tsx` | 9 | Formula editor |
| `components/dev/CameraDbManager.tsx` | 9 | Camera DB manager |
| `components/dev/LicenseTools.tsx` | 9 | License tools |
| `components/dev/DebugTools.tsx` | 9 | Debug tools |

### Resources

| File | Step | Purpose |
|------|------|---------|
| `resources/cameras/canonical.json` | 5 | Bundled camera DB (can start as `[]`) |

### New Database Migrations

| Migration | Step | Tables/Changes |
|-----------|------|----------------|
| 4 | 4 | export_history |
| 5 | 5 | camera_devices + ALTER clips ADD camera_device_id |

### New Cargo Dependencies

| Crate | Step | Purpose |
|-------|------|---------|
| `keyring` | 3 | OS keychain for license key storage |

---

## New Commands Summary (26 total)

| Step | Module | Commands |
|------|--------|----------|
| 2 | jobs | cancel_job |
| 3 | licensing | get_license_state, activate_license, deactivate_license, is_feature_allowed |
| 4 | export | start_vhs_export, get_export_history, cancel_export |
| 5 | cameras | list_camera_profiles, list_camera_devices, register_camera_device, match_camera, import_camera_db, export_camera_db |
| 6 | import | (modify existing start_ingest signature) |
| 9 | devmenu | test_ffmpeg, clear_caches, export_database, export_exif_dump, execute_raw_sql, generate_rental_keys, get_db_stats |

After v0.2.0: 38 existing + 26 new = **64 Tauri commands**.

---

## Testing Checklist (Must-Pass Before Ship)

### Licensing

- [ ] Fresh install starts 14-day trial
- [ ] Trial banner shows correct days remaining
- [ ] Trial banner has "Enter License Key" CTA button
- [ ] Key entry modal accessible from trial banner CTA
- [ ] Key entry modal accessible from Dev Menu > License Tools
- [ ] After trial expires: import blocked with clear message
- [ ] After trial expires: new scoring/analysis jobs blocked
- [ ] After trial expires: rendered export has watermark AND 720p cap (both)
- [ ] After trial expires: export originals (file copy) always works
- [ ] Valid purchased key activates correctly
- [ ] Valid rental key activates correctly
- [ ] Dev key (`DCAM-D-...`) enables raw SQL in dev menu
- [ ] Invalid key shows error, does not activate
- [ ] After activation, trial banner disappears

### Settings Migration + First-Run Wizard

- [ ] v1 settings migrate to v2 on first load
- [ ] "personal" maps to "simple", "pro" maps to "advanced"
- [ ] Existing users get firstRunCompleted = true (no wizard)
- [ ] Feature flags initialized with correct defaults per mode
- [ ] Dev menu settings initialized with correct defaults
- [ ] Fresh install shows first-run wizard before any other screen
- [ ] Wizard step 1 sets mode (Simple or Advanced)
- [ ] Simple wizard step 2 picks default project folder
- [ ] Advanced wizard step 2 goes to projects dashboard
- [ ] After wizard, firstRunCompleted = true, wizard never shows again

### VHS Export

- [ ] Pipeline handles mixed codecs without FFmpeg errors
- [ ] Pipeline handles clips with no audio track
- [ ] Audio crossfades smooth (no pops/silence)
- [ ] Title overlay appears at correct time (default 5s), fades in/out
- [ ] Watermark + 720p enforced when license expired
- [ ] Export history records created with correct metadata
- [ ] Cancel stops export, cleans up partial file
- [ ] Chronological, score desc, score asc, shuffle orderings all work
- [ ] Score threshold selection available only in Advanced mode

### Import

- [ ] Import survives crash/interruption and resumes
- [ ] Event assignment creates correct event_clips rows
- [ ] New event created inline during import
- [ ] Camera detection never blocks import (generic fallback)
- [ ] Import blocked when trial expired
- [ ] Progress bar updates in real time
- [ ] Cancel stops import cleanly
- [ ] Camera breakdown shows in import summary (Advanced only)

### Camera System

- [ ] Ingest works with empty canonical.json (generic fallback)
- [ ] Known camera model matched by make+model
- [ ] Custom device registered from sample clips
- [ ] USB fingerprint captured (best-effort, no crash on failure)
- [ ] Camera breakdown shows in import summary (Advanced mode)
- [ ] Unknown cameras silent in Simple mode

### Sidecars

- [ ] Sidecar JSON written to `.dadcam/sidecars/` during ingest
- [ ] Sidecar NOT written next to originals
- [ ] Sidecar contains: original path, hash, metadata, camera match, timestamps, derived paths
- [ ] Export EXIF dump works from dev menu

### Cross-Platform

- [ ] Keychain storage works on macOS
- [ ] Keychain storage works on Windows
- [ ] Keychain storage works on Linux
- [ ] Bundled FFmpeg callable on all platforms
- [ ] Dev menu shortcuts work (Cmd+Shift+D / Ctrl+Shift+D)
- [ ] Same features available on all three platforms (contract 15)

### Dev Menu

- [ ] Hotkey opens dev menu
- [ ] Easter egg (7 clicks on version) opens dev menu
- [ ] Formula changes persist and affect export behavior
- [ ] Camera DB import/export works
- [ ] FFmpeg test shows version
- [ ] Clear caches deletes correct files (not originals, not DB)
- [ ] Export database copies .db file
- [ ] Raw SQL gated behind Dev key

### LeftNav + Feature Toggles + Theme

- [ ] Favorites link filters clips correctly
- [ ] Cameras tab gated by mode + feature flag
- [ ] Feature toggles visible only in Advanced mode
- [ ] Theme toggle visible only in Advanced mode
- [ ] Dark mode applies correctly via CSS class
- [ ] Theme persists across restart

---

## Packaging / FFmpeg Bundling

Reference: Master plan section "Packaging / External Dependencies"

Contract 18 requires FFmpeg, ffprobe, and exiftool to be bundled with the app. The codebase uses `ffmpeg-sidecar` crate which handles FFmpeg auto-download during development.

For production builds:
- **macOS**: FFmpeg binaries placed in `Contents/Resources/` via Tauri sidecar config in `tauri.conf.json`
- **Windows**: FFmpeg binaries placed alongside the .exe
- **Linux**: FFmpeg binaries placed in the AppImage or alongside the binary

The resolution order (from `tools.rs`):
1. Environment variable override (`FFMPEG_PATH`, `FFPROBE_PATH`)
2. Tauri sidecar managed path
3. macOS Resources directory
4. System PATH fallback

Dev menu includes an "FFmpeg test" button that runs `ffmpeg -version` to verify the bundled binary is working.

---

## Cross-References

| Topic | File |
|-------|------|
| Product definition | `about.md` |
| Architectural contracts | `contracts.md` |
| Technical manual | `techguide.md` |
| Version history | `changelog.md` |
| Master plan (source) | `docs/planning/v0.2.0-master-plan.updated.md` |
| Braun design specs | CSS variables in `App.css`, Appendix D in `docs/planning/dashboard-redesign.md` |
| Current schema | `src-tauri/src/db/migrations.rs` (3 migrations, 17 tables) |
| Current constants | `src-tauri/src/constants.rs` |
| Current settings code | `src-tauri/src/commands/settings.rs` (v1, Personal/Pro enum) |
| Current settings types | `src/types/settings.ts` (v1) |
| Current command registration | `src-tauri/src/lib.rs` (generate_handler macro, 38 commands) |
| Command modules | `src-tauri/src/commands/mod.rs` (7 modules: library, clips, tags, scoring, settings, stills, events) |
| Camera matching | `src-tauri/src/camera/mod.rs` |
| Ingest pipeline | `src-tauri/src/ingest/` |
| Job system | `src-tauri/src/jobs/` |
| Preview pipeline | `src-tauri/src/preview/` |
| Scoring engine | `src-tauri/src/scoring/` |

---

## Decisions Log (Carried from Master Plan)

These are decided. Do not revisit unless the user explicitly reopens.

- Mode persistence: `simple | advanced` (stored enum, not UI-only)
- Trial soft lock: block import + new auto-edit jobs; allow rendered export with watermark + 720p; always allow exporting originals
- Bundle FFmpeg (offline requirement, contract 18)
- Events remain many-to-many via join table (do not add event_id to clips)
- Cameras modeled as Profile + Device (two tables)
- USB registration best-effort; "register from sample clips" is the reliable baseline
- canonical.json source TBD; system works without it
- Terminology rename (personal/pro -> simple/advanced) done in Step 1 for data/types, cosmetic UI rename done last

---

## Audit Notes (2026-01-28, updated 2026-01-29)

This guide was originally audited pre-implementation (2026-01-28), then synced post-implementation (2026-01-29) to match the built codebase at v0.1.103.

### Pre-implementation audit (2026-01-28)

| File | What was verified |
|------|-------------------|
| `src-tauri/src/lib.rs` | 38 commands in generate_handler macro (lines 86-131) |
| `src-tauri/src/commands/mod.rs` | 7 command modules (library, clips, tags, scoring, settings, stills, events) |
| `src-tauri/src/commands/settings.rs` | SETTINGS_VERSION=1, AppMode=Personal/Pro, AppSettings has 4 fields, RecentLibrary has 5 fields |
| `src-tauri/src/db/migrations.rs` | 3 migrations, 17 tables total (13+2+2), PRAGMA user_version |
| `src-tauri/Cargo.toml` | All listed dependencies match, keyring not yet added |
| `src/types/settings.ts` | AppMode='personal'/'pro', AppSettings has version/mode/lastLibraryPath/recentLibraries |
| `src/App.tsx` | Routes on loading/library/unmounted/mode, no wizard gate yet, no dark mode toggle |
| `src/components/` | 28 components verified: 21 root .tsx + 3 modals + 4 nav |
| `package.json` | react 19.1.0, typescript 5.8.3, vite 7.0.4 |
| `src-tauri/src/constants.rs` | PIPELINE_VERSION=1, SCORING_VERSION=1, all scoring weights 0.25 |
| `docs/planning/v0.2.0-master-plan.updated.md` | All 19 sections cross-referenced to guide steps |
| `contracts.md` | All 18 contracts verified, key contracts called out in guide |
| `about.md` | Product definition verified |
| `techguide.md` | Tech stack, architecture, CLI commands verified (version 0.1.62) |

### Post-implementation sync (2026-01-29)

| Item | Change |
|------|--------|
| Dev menu commands | 6 -> 7 (added get_db_stats for table counts, db size, migration version) |
| New command total | 25 -> 26, overall 63 -> 64 |
| Step 9 Debug section | Added live log viewer (job-progress events, last 200 lines), database stats, native save dialogs for export database and EXIF dump |
| Step 9 Camera DB section | Updated to full profile/device tables (not just counts), native file dialogs for import/export |
| Step 9 License Tools | Added inline key activation with text input and validation feedback |
| Step 10 macOS USB | Updated to -xml plist parsing (stable across macOS versions) |
| Step 10 Windows USB | Updated to PowerShell Get-CimInstance (replaces deprecated wmic), regex VID/PID extraction |
| Step 10 safety | Added std::panic::catch_unwind wrapping, root hub filtering, fingerprint deduplication |

**Improvements over previous guide version:**
- Added "Getting Started" section with build/run instructions
- Added "How the App Works" architecture explanation for newcomers
- Added Tauri concepts explanation (commands, events, Store plugin, DbState)
- Added FFmpeg bundling strategy section with per-platform details
- Made trial start logic more prominent (from master plan "Migration" section)
- Added explicit master plan section references to every step header
- Added line number references for key source locations
- Added explanation of why start_ingest uses its own DB connection
- Added explanation of why forward-only migrations matter
- Expanded "Gotchas" sections with more context for each concept
- 70+ testing checklist items across 9 categories

---

End of Implementation Guide
