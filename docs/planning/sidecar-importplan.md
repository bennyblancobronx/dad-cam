# sidecar-importplan.md
**Dad Cam App -- Sidecar Files: Gold-Standard Import + Verification Plan**
**Goal:** Sidecar files (THM, XML, XMP, SRT, LRF, IDX) must follow the EXACT same gold-standard import pipeline as primary media files, with bit-level integrity, completeness proof, and crash-safe atomic writes -- so they are covered by the SAFE TO WIPE gate and included in all audit artifacts.

---

## 0) Definitions + Problem Statement

### 0a) Definitions (what "gold standard" means -- same as importplan.md)
- **Integrity (bit-level):** the bytes in the library copy are *identical* to the bytes on the source device at the time of ingest. Proof uses **full-file cryptographic hashes** (fixity). [R3][R4][R7]
- **Completeness:** you imported *all eligible files that existed on the device at the start of the session*, and you detected if the device changed during ingest. A manifest + rescan closes that gap. [R4]
- **Crash-safety:** ingest never produces a "final" library file unless it's fully verified; partial copies only exist as temp files. Atomic replace patterns use temp-write + fsync + rename + fsync(dir). [R1][R2]

These definitions apply to sidecar files identically -- a THM or SRT is subject to the same integrity, completeness, and crash-safety guarantees as an MP4.

### 0b) Terminology note

Two distinct "sidecar" concepts exist in Dad Cam. This document concerns **only the first**:

1. **Sidecar files** (this plan): THM, XML, XMP, SRT, LRF, IDX files that ship alongside camera media on a source device. These are raw originals that must be preserved per Contract #7. Defined in `constants.rs:75` as `SIDECAR_EXTENSIONS`.
2. **Sidecar JSON metadata** (unrelated): Per-clip metadata snapshots written by Dad Cam to `.dadcam/sidecars/<clip_id>.json` during indexing. These are derived artifacts generated by the app, not imported from device. Defined in `ingest/sidecar.rs`.

These two systems share a name but have no overlap. Changes in this plan do not affect the `.dadcam/sidecars/` JSON system.

### 0c) Problem statement (what is wrong today)

Today, sidecar files are:
- **Not tracked in IngestManifestEntry** -- they are discovered *after* the main file is ingested, as a secondary step (`ingest/mod.rs:591-597`).
- **Not included in the rescan gate** -- `run_rescan()` calls `discover_media_files()` which only finds media, not sidecars (`ingest/mod.rs:677`).
- **Not included in audit artifacts** -- `audit.rs` export structs (`ManifestExportEntry`, `ResultExportEntry`) have no `entry_type` field; rescan in `audit.rs:145` calls `discover_media_files()` only.
- **Not hashed during copy** -- `ingest_sidecar()` (`ingest/mod.rs:862-899`) calls `copy_file_to_library()` which returns a hash, but that hash is discarded (line 876: `let (dest, _hash)`). The sidecar asset record has `hash_fast: None`.
- **Failures are warnings, not errors** -- a failed sidecar copy logs to stderr and moves on (`ingest/mod.rs:595`: `eprintln!("Warning: ...")`).

This violates Contract #7 ("Sidecars travel with their parent video") and the importplan.md invariant #2 ("Never show SAFE TO WIPE unless every manifest entry is verified AND the rescan matches").

---

## 1) Non-negotiable promises (invariants -- same as importplan.md)

All five invariants from importplan.md apply identically to sidecar files:

1. **Never mark a sidecar verified unless source-hash == dest-hash.**
2. **Never show SAFE TO WIPE unless every manifest entry (including sidecars) is verified AND the rescan matches.**
3. **Never write directly to the final destination path.** (temp -> verify -> atomic rename)
4. **Dedup never skips verification.** (If a sidecar is identical to one already in the library, full-hash must confirm before dedup.)
5. **Every decision has evidence** stored in DB + exportable logs.

---

## 2) Threat model (additions for sidecars)

Same threats as importplan.md section 2, plus:
- Sidecar file present at discovery but deleted/moved before copy (camera still writing, user moves files)
- Sidecar discovered for one clip but actually belongs to another (stem collision from different folders)
- Sidecar format changes mid-session (camera writes partial THM/XML until recording finishes)
- Orphan sidecars on source device that have no matching media file (should still be inventoried and preserved per Contract #7: "Preserve ALL unknown files in source folder structure")

---

## 3) Required data model changes

### 3.1 IngestManifestEntry (existing table, new usage)

Sidecars must get their own rows in `ingest_manifest_entries`, same as media files. The existing schema already supports this. New fields or conventions:

| Field | Sidecar usage |
|-------|---------------|
| `relative_path` | Path of sidecar file relative to source root |
| `size_bytes` | Sidecar file size |
| `mtime` | Sidecar file mtime |
| `hash_fast` | Optional fast hash (same scheme as media) |
| `hash_source_full` | BLAKE3 full hash of source sidecar (required for SAFE TO WIPE) |
| `asset_id` | Points to the sidecar asset record once ingested |
| `result` | Same enum: `copied_verified`, `dedup_verified`, `skipped_ineligible`, `failed`, `changed` |
| `entry_type` | **NEW column needed**: `media` or `sidecar` -- to distinguish in queries and audit exports |
| `parent_entry_id` | **NEW column needed** (nullable): FK to the manifest entry of the parent media file this sidecar belongs to. NULL for orphan sidecars. |

### 3.2 Asset verification fields (no change)

Sidecar assets already have `type = 'sidecar'` in the assets table. The existing `hash_full`, `verified_at`, `verified_method` columns apply identically.

---

## 4) Canonical pipeline (gold-standard for sidecars)

### 4.1 Session: Discover -> Manifest (sidecars included)

**Change from current behavior:** Sidecar discovery happens DURING manifest building, not after individual file ingestion.

**Checklist**
- [ ] Walk source directory for eligible media files (existing behavior).
- [ ] For EACH media file found, also call `discover_sidecars()` to find associated sidecar files.
- [ ] Write a manifest entry for each sidecar with `entry_type = 'sidecar'` and `parent_entry_id` pointing to the media file's manifest entry.
- [ ] Also discover orphan sidecars: files matching `SIDECAR_EXTENSIONS` that do NOT match any media file stem. These get `entry_type = 'sidecar'` with `parent_entry_id = NULL`.
- [ ] Include all sidecar entries when computing `manifest_hash`.

**Why**
- Completeness requires knowing about ALL files (media + sidecars) at the start. Discovering sidecars lazily after copying the parent means they are invisible to the rescan gate.

**Evidence**
- `IngestSession.manifest_hash` now covers sidecars.
- `manifest.jsonl` includes sidecar entries (identifiable by `entry_type`).

### 4.2 File: Copy with read-back verification (streaming) -- same algorithm

**Do this for every sidecar manifest entry, same as media files.**

The algorithm is IDENTICAL to importplan.md section 4.2:

1. Open source sidecar; re-stat; compare to manifest `(size, mtime)`.
   - If changed -> mark `result=changed`, block SAFE TO WIPE.
2. Create dest temp file on SAME filesystem as final library path: `dest.final.<uuid>.tmp`
3. Stream loop: read chunk -> update BLAKE3 hasher -> write chunk to temp.
4. `fsync(temp dest file)`
5. Close temp dest.
6. Read temp dest back from disk (stream) and compute dest full hash.
7. Compare `hash_source_full == hash_dest_full`
   - If mismatch: delete temp dest, mark failed, **block SAFE TO WIPE**.
   - If match: atomic rename temp -> final path, then `fsync(parent dir)`.
8. Write/update DB:
   - Asset `hash_full = hash_dest_full`
   - Asset `verified_at = now`, `verified_method = copy_readback`
   - ManifestEntry `hash_source_full`, `asset_id`, `result = copied_verified`

**Key difference from today:** A failed sidecar copy is a HARD FAILURE on the manifest entry, not a warning. It blocks SAFE TO WIPE.

**Evidence**
- Per sidecar: stored `hash_source_full`, `hash_full`, `verified_at`, audit record showing compare result.

### 4.3 File: Dedup that is still safe-to-wipe -- same algorithm

If a sidecar's fast hash matches an existing asset:
- [ ] Compute full source hash anyway (stream source once)
- [ ] Compare to candidate asset's stored `hash_full`
- [ ] If match: link manifest entry to existing asset, set `result=dedup_verified`, `verified_method=dedup_match`
- [ ] If no match: treat as unique -> do full copy pipeline

**Evidence**
- ManifestEntry shows `dedup_verified` with `asset_id` and `hash_source_full`

### 4.4 Session: Rescan gate for SAFE TO WIPE (sidecars included)

**Change from current behavior:** Rescan must cover sidecars.

After ingest attempts complete:
- [ ] Rescan source device for ALL eligible files (media + sidecars).
- [ ] For each media file in rescan, also discover its sidecars.
- [ ] Also discover orphan sidecars in rescan.
- [ ] Compare rescan snapshot to original manifest:
  - No missing entries (media or sidecar) from manifest
  - No new eligible files (media or sidecar) added
  - No changed metadata that indicates modifications
- [ ] Only if:
  - ALL manifest entries (media AND sidecar) are `copied_verified` or `dedup_verified`
  - AND rescan matches
  -> set `safe_to_wipe_at = now` and show SAFE TO WIPE.

**Why**
- A session where all videos verified but a sidecar failed or a new SRT appeared mid-ingest is NOT safe to wipe. Completeness must cover every file type.

**Evidence**
- `IngestSession.rescan_hash` now covers sidecars.
- `rescan_diff.json` includes sidecar differences (must be empty for SAFE).

---

## 5) Deletion/Wipe workflow (no change to logic, expanded scope)

Same as importplan.md section 5. The SAFE TO WIPE gate already blocks if any manifest entry (now including sidecars) is not verified.

**What changes in practice:** The existing `wipe_source_files()` (`ingest/mod.rs:736+`) iterates all manifest entries by `relative_path` to build the delete list. Because sidecar entries now live in the same `ingest_manifest_entries` table, they are automatically included in the wipe without any code change to the wipe function itself. The delete loop deletes `source_root / entry.relative_path` for every entry -- media and sidecar alike.

**Checklist (confirm, no new code needed):**
- [ ] `wipe_source_files()` iterates ALL manifest entries (media + sidecar) -- verify no `WHERE entry_type = 'media'` filter exists.
- [ ] Wipe report includes sidecar paths in its per-file outcomes.
- [ ] If a sidecar file was already removed from source (e.g., user manually deleted it), the wipe logs the missing file but does not fail the overall wipe.

---

## 6) Error handling (sidecars are not second-class)

**Must implement (change from today):**
- If sidecar read-back compare fails: mark sidecar entry failed, **block SAFE TO WIPE** (today this is a warning).
- If sidecar file disappeared between manifest and copy: mark `result=changed`, block SAFE TO WIPE.
- If sidecar copy fails for I/O: capture errno + path in `error_detail`, mark failed, block SAFE TO WIPE.
- Parent media file success does NOT imply sidecar success. Each is independent.

**Edge case -- sidecar verified but parent failed:**
If a sidecar's `result = copied_verified` but its parent media entry has `result = failed`, SAFE TO WIPE is still blocked (because the parent failed). This is correct and expected -- no special handling needed. The sidecar's verification stands on its own, but the session-level gate requires ALL entries to pass. The reverse (parent verified, sidecar failed) also blocks SAFE TO WIPE. Neither direction gets special treatment.

**Evidence**
- Structured error codes in sidecar manifest entries and session summary.

---

## 7) UX requirements

- Session status already shows `Discovering -> Copying -> Read-back verifying -> Rescanning -> SAFE TO WIPE`. No change to flow, but counts must include sidecars.
- Progress bar file counts: include sidecars in totals (e.g., "Copying 47/52 files (5 sidecars)").
- Audit report export includes sidecar entries in manifest.jsonl and results.jsonl.
- If only sidecars failed, the UI should clearly indicate "3 sidecar files failed verification" rather than just "3 files failed".

---

## 8) Performance notes

- Sidecar files are typically small (THM: ~20KB, XML: ~5KB, XMP: ~2KB, SRT: ~10KB). The streaming copy + read-back overhead is negligible.
- Discovery adds one `discover_sidecars()` call per media file during manifest building. This checks ~6 extensions x 2 (upper/lower) = 12 stat() calls per file. On a 500-file card this is 6000 stat() calls, which is fast even on SD cards.

---

## 9) Required audit artifacts (expanded)

Same export format as importplan.md section 9, but sidecar entries are now present:
- `manifest.jsonl` -- includes sidecar entries with `entry_type: "sidecar"` and `parent_entry_id`
- `results.jsonl` -- includes per-sidecar hashes, method, timestamps, errors
- `rescan.jsonl` -- includes sidecar files found on rescan
- `rescan_diff.json` -- diffs include sidecar additions/removals/changes (must be empty for SAFE)

---

## 10) Test plan (sidecar-specific, in addition to importplan.md tests)

**Integrity**
- [ ] Corrupt a sidecar dest after copy (flip a byte) -> read-back compare must fail; sidecar not accepted; SAFE TO WIPE blocked.

**Completeness**
- [ ] Add a new SRT file to device after manifest -> rescan diff must block SAFE TO WIPE.
- [ ] Delete a THM file from device after manifest -> rescan diff must block SAFE TO WIPE.

**Crash safety**
- [ ] Simulate crash mid-sidecar-copy -> only temp file exists; parent clip's primary asset is unaffected.

**Orphan handling**
- [ ] Place a standalone XMP file (no matching media stem) on device -> must appear in manifest and be copied+verified.

**Error escalation**
- [ ] Sidecar copy fails (simulate I/O error) -> SAFE TO WIPE is blocked even though parent media file verified OK.

**Dedup**
- [ ] Same SRT file appears on two different cards (same content, different path) -> second session deduplicates via full hash, manifest entry shows `dedup_verified`.

**AVCHD structure**
- [ ] AVCHD folder with THM files inside nested `PRIVATE/AVCHD/BDMV/` structure -> sidecars discovered and preserved with folder structure intact per Contract #7.

**Case sensitivity**
- [ ] Source device has `VIDEO.THM` (uppercase) -> discovered by the upper-case check in `discover_sidecars()` and treated identically to lowercase.

**Ordering**
- [ ] Parent media file is processed before its sidecars in the manifest -> after parent creates clip record, sidecar links to it successfully via `link_clip_asset()`.

**Backward compat**
- [ ] Resume an incomplete session that was created before migration 10 -> completes under old rules (no sidecar manifest entries added retroactively), no crash.

---

## 11) "Done" definition (acceptance criteria)

A session is SAFE TO WIPE iff:
- `forall manifest_entry WHERE entry_type IN ('media', 'sidecar'): result IN {copied_verified, dedup_verified}`
- `rescan_diff == empty` (including sidecars)
- All verified assets (media AND sidecar) have `hash_full` and `verified_at` set
- Audit artifacts export succeeds and includes sidecar entries

---

## 12) Implementation checklist (code changes required)

### 12.1 Database -- Migration 10 (`db/migrations.rs`)

Add a new entry to the `MIGRATIONS` array after migration 9:

```sql
-- Migration 10: Sidecar gold-standard import (sidecar-importplan.md)
ALTER TABLE ingest_manifest_entries ADD COLUMN entry_type TEXT NOT NULL DEFAULT 'media'
    CHECK (entry_type IN ('media', 'sidecar'));
ALTER TABLE ingest_manifest_entries ADD COLUMN parent_entry_id INTEGER
    REFERENCES ingest_manifest_entries(id);
CREATE INDEX idx_manifest_entry_type ON ingest_manifest_entries(entry_type);
CREATE INDEX idx_manifest_parent ON ingest_manifest_entries(parent_entry_id);
```

- [ ] Add migration SQL to `MIGRATIONS` array
- [ ] Add `entry_type` and `parent_entry_id` to `ManifestEntry` struct (`db/schema.rs:1520`)
- [ ] Add `entry_type` and `parent_entry_id` to `NewManifestEntry` struct (`db/schema.rs:1540`)
- [ ] Update `insert_manifest_entry()` to accept new fields (`db/schema.rs:1545`)
- [ ] Update `get_manifest_entries()` SELECT to include new columns (`db/schema.rs:1554`)
- [ ] Update `get_pending_manifest_entries()` similarly (`db/schema.rs:1581`)

Backward compatibility: existing manifest entries from migration 9 sessions get `entry_type = 'media'` (the DEFAULT) and `parent_entry_id = NULL`. These sessions remain valid -- they simply have no sidecar tracking, which is correct because their sidecars were handled by the old warning-only path.

### 12.2 Discovery phase (`ingest/discover.rs`)

New function needed:

```rust
/// Discover all sidecar files in a directory (orphans included).
/// Returns (media_sidecars, orphan_sidecars).
/// media_sidecars: Vec<(media_path, Vec<sidecar_path>)>
/// orphan_sidecars: Vec<PathBuf> -- sidecar-extension files with no matching media stem
pub fn discover_all_sidecars(
    source_path: &Path,
    media_files: &[PathBuf],
) -> (Vec<(PathBuf, Vec<PathBuf>)>, Vec<PathBuf>)
```

- [ ] Add `discover_all_sidecars()` function
- [ ] Build a set of known media stems per directory from `media_files`
- [ ] Walk source directory for sidecar-extension files; match stems to media stems
- [ ] Unmatched sidecar-extension files go into orphan list
- [ ] Existing `discover_sidecars()` remains for backward compat but is no longer called during ingest

### 12.3 Manifest building (`ingest/mod.rs`, around line 105-140)

Currently manifest is built by iterating `discover_media_files()` results. Change to:

- [ ] After discovering media files, call `discover_all_sidecars(source_root, &media_files)`
- [ ] For each media file's sidecars: insert manifest entry with `entry_type = 'sidecar'`, `parent_entry_id` = the media file's manifest entry ID
- [ ] For each orphan sidecar: insert manifest entry with `entry_type = 'sidecar'`, `parent_entry_id = NULL`
- [ ] Include sidecar entries when computing `manifest_hash`

### 12.4 Copy phase (`ingest/mod.rs`)

- [ ] In `process_single_file()`: remove lines 591-597 (the `discover_sidecars` + `ingest_sidecar` loop with warning-only error handling)
- [ ] Instead, sidecar manifest entries are processed by the same `copy_with_verify` pipeline that handles media entries. The main ingest loop already iterates `get_pending_manifest_entries()` -- sidecar entries will appear there automatically once they are in the manifest.
- [ ] Ensure copy destination respects folder structure: sidecar goes to `originals/<relative_dir>/<sidecar_filename>` (same directory as its parent media)
- [ ] After sidecar copy+verify succeeds, create asset record with `type = 'sidecar'` and link to parent clip via `link_clip_asset()`
- [ ] Delete or deprecate `ingest_sidecar()` function (`ingest/mod.rs:862-899`)

Ordering: parent media files should be processed before their sidecars so the clip record exists for linking. The manifest builder should insert media entries first, then sidecar entries. Since `get_pending_manifest_entries()` returns rows ordered by `id` (auto-increment), insertion order guarantees processing order.

### 12.5 Rescan phase (`ingest/mod.rs:655-734`)

- [ ] In `run_rescan()`, replace `discover_media_files()` call (line 677) with a combined walk that returns both media and sidecar files
- [ ] New helper: `discover_all_eligible_files(source_root)` that returns media + sidecar paths
- [ ] Build rescan snapshot from combined results
- [ ] Compare rescan snapshot against full manifest (media + sidecar entries)
- [ ] A missing or new sidecar on source blocks SAFE TO WIPE identically to a missing media file

### 12.6 Audit export (`ingest/audit.rs`)

- [ ] Add `entry_type` and `parent_entry_id` to `ManifestExportEntry` struct (line 41)
- [ ] Add `entry_type` and `parent_entry_id` to `ResultExportEntry` struct (line 48)
- [ ] In `export_audit_report()`, replace `discover_media_files()` call (line 145) with `discover_all_eligible_files()` to include sidecars in rescan.jsonl
- [ ] Rescan diff must compare against full manifest including sidecar entries

### 12.7 UX (Tauri commands / frontend)

- [ ] Progress counts: when emitting `JobProgress`, include sidecar count in total. Display as "Copying 47/52 files (5 sidecars)" or similar.
- [ ] Session summary: report sidecar counts separately (e.g., "42 media files verified, 10 sidecar files verified")
- [ ] Error display: if only sidecars failed, message must say "X sidecar files failed" not just "X files failed"
- [ ] Wipe report: sidecar paths included in wipe manifest

---

## 13) Backward compatibility and migration safety

### Existing sessions (pre-migration-10)

Sessions created under migration 9 have no `entry_type` or `parent_entry_id` columns. After migration 10:
- All existing manifest entries get `entry_type = 'media'` (column DEFAULT).
- All existing manifest entries get `parent_entry_id = NULL`.
- Existing sessions that are already `safe_to_wipe_at IS NOT NULL` remain valid. Their sidecars were handled by the old `ingest_sidecar()` path (best-effort), and the user already wiped or chose not to. Re-evaluating them is not required.
- Existing sessions that are still `safe_to_wipe_at IS NULL` (incomplete) can be resumed. On resume, sidecars will NOT be retroactively added to the manifest. The session completes under the old rules (media-only manifest). This is acceptable because the session was started under the old contract.

### New sessions (post-migration-10)

All sessions created after migration 10 follow this plan. Sidecars are first-class manifest entries from discovery onward.

### Rollback

If migration 10 must be rolled back (forward-only policy per contracts, but for disaster recovery): the two new columns can be dropped without data loss to existing columns. No existing data depends on them.

---

## 14) Execution order summary

For clarity, the full session lifecycle with sidecars integrated:

```
1. CREATE SESSION
   |
2. DISCOVER (walk source)
   |-- discover_media_files() -> media list
   |-- discover_all_sidecars(source, media_list) -> (paired sidecars, orphans)
   |
3. BUILD MANIFEST
   |-- Insert media entries (entry_type='media')
   |-- Insert paired sidecar entries (entry_type='sidecar', parent_entry_id=media_entry.id)
   |-- Insert orphan sidecar entries (entry_type='sidecar', parent_entry_id=NULL)
   |-- Compute manifest_hash over ALL entries
   |
4. COPY + VERIFY (iterate pending manifest entries by id order)
   |-- For each entry (media or sidecar):
   |     re-stat -> temp copy -> stream hash -> fsync -> read-back hash -> compare
   |     -> atomic rename -> update DB (asset, manifest entry)
   |-- Media entries processed first (lower IDs), then sidecars
   |-- After each media entry: clip record exists for sidecar linking
   |
5. RESCAN GATE
   |-- Re-walk source for ALL eligible files (media + sidecars)
   |-- Compare to manifest (no missing, no new, no changed)
   |-- Check all manifest entries are copied_verified or dedup_verified
   |-- If all pass: safe_to_wipe_at = now
   |
6. SAFE TO WIPE (or not)
```

---

## References
(Same as importplan.md R1-R7. Reproduced here so this document stands alone.)

```text
[R1] Linux man-pages: fsync(2) -- notes that fsync flushes data/metadata and that directory entries may require fsync on the directory too.
https://man7.org/linux/man-pages/man2/fsync.2.html

[R2] Linux man-pages: rename(2) -- states that if newpath exists it is atomically replaced (atomic rename semantics on local filesystems).
https://man7.org/linux/man-pages/man2/rename.2.html

[R3] Library of Congress (The Signal): "File Fixity and Data Integrity" -- checksum comparison as fixity checking/auditing; bit change changes checksum.
https://blogs.loc.gov/thesignal/2014/04/protect-your-data-file-fixity-and-data-integrity/

[R4] NDSA Fixity Guidance Report (PDF) -- fixity as bit-level integrity; checksums/hashes provide evidence one set of bits is identical to another.
https://www.digitalpreservation.gov/documents/NDSA-Fixity-Guidance-Report-final100214.pdf

[R5] IETF Internet-Draft: "The BLAKE3 Hashing Framework" -- BLAKE3 specified as secure, fast, parallelizable.
https://www.ietf.org/archive/id/draft-aumasson-blake3-00.html

[R6] BLAKE3 project documentation -- notes speed, security, and incremental/streaming capability due to Merkle-tree structure.
https://github.com/BLAKE3-team/BLAKE3

[R7] DPC Digital Preservation Handbook: Fixity and checksums -- compute checksums for copies and compare to known-good reference.
https://www.dpconline.org/handbook/technical-solutions-and-tools/fixity-and-checksums
```
